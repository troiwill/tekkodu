// INCLUDES
// c++
#include <cctype>
#include <iostream>
#include <queue>
#include <vector>

// tekkotsu
#include "Behaviors/StateMachine.h"
#include "DualCoding/VRmixin.h"

// tekkodu
#include "Kodu/KoduIncludes.h"

// General Functions
#include "Kodu/General/GeneralFncs.h"
#include "Kodu/General/GeneralMacros.h"

// Kodu Parsing
#include "Kodu/Parsing/Parser.h"

#include "Kodu/Keepers/ScoreKeeper.h"
#include "Kodu/Keepers/ObjectKeeper.h"
#include "Kodu/KoduPage.h"
#include "Kodu/KoduRule.h"

$nodeclass KoduInterp : VisualRoutinesStateNode {
    
    $provide Kodu::KoduWorld* theWorld(NULL);
    $provide Kodu::KoduAgent* thisAgent(NULL);
    
    $provide DropActionRunner* dropActRef(NULL);
    $provide GrabActionRunner* grabActRef(NULL);
    $provide MotionActionRunner* motionActRef(NULL);
    $provide PageSwitchActionRunner* pageSwitchActRef(NULL);

    $provide PlayActuator* playActRef(NULL);
    $provide SayActuator* sayActRef(NULL);
    $provide ScoreActuator* scoreActRef(NULL);

    $provide PerceptualMultiplexor* multiplexorRef(NULL);

    $provide bool needToHaltExecution(false);
    $provide KoduConditionEvaluator* evaluatorRef(NULL);
    $provide KoduActionRunner* runnerRef(NULL);
    
    ~KoduInterp() {
        std::cout << "Destructing Kodu Game...\n";
        // null the KoduAgent pointer
        thisAgent = NULL;

        // delete the world instance
        std::cout << "Destroying Kodu World.\n";
        GeneralFncs::deletePtr(theWorld);
        
        std::cout << "Kodu Game destruction complete!\n";
    }

    $nodeclass InitializeAgent : StateNode {

        $nodeclass CreateWorld : StateNode : doStart {
            $reference KoduInterp::theWorld;
            $reference KoduInterp::thisAgent;

            std::cout << "[" << getName() << "]: creating world\n";
            // create an instance of the Kodu World
            if ((theWorld = new Kodu::KoduWorld()) == NULL) {
                std::cout << "!!! there was an error creating the World! Terminating...\n";
                postStateFailure();
                return;
            }
            // create a pointer to the agent instance in KoduWorld
            thisAgent = &(theWorld->thisAgent);
            postStateCompletion();
        }

        $nodeclass ParseKode : StateNode : doStart {
            std::cout << "[" << getName() << "]: parsing kode\n";
            $reference KoduInterp::thisAgent;
            // parses and creates Kodu program
            if (Kodu::Parser::parseAndCreateKoduProgram(thisAgent->pages) == false) {
                std::cerr << "!!! Error parsing and creating Kodu program.\n";
                postStateFailure();
                return;
            }
            std::cout << "parsing complete.\n";
            postStateSuccess();
        }

        $nodeclass LookAround : MapBuilderNode(MapBuilderRequest::worldMap) : doStart {
            std::cout << "[" << getName() << "]: looking for objects.\n";
            // search for red, blue, and green cylinders
            mapreq.addObjectColor(cylinderDataType, "red");
            mapreq.addObjectColor(cylinderDataType, "blue");
            mapreq.addObjectColor(cylinderDataType, "green");
            mapreq.setAprilTagFamily();
            
            // get the gaze points from the agent
            $reference KoduInterp::thisAgent;
            std::vector<Point> searchPoints(thisAgent->getGazePoints());

            const float kSearchRadius = 1500.0f;
            const float kZval = 300.0f;
            // now add the approx. search points for the april tags (star constellation)
            // direct left
            searchPoints.push_back(Point(cos(deg2rad( 90.0f)) * kSearchRadius,
                                         sin(deg2rad( 90.0f)) * kSearchRadius,
                                         kZval, egocentric));

            // forward left
            searchPoints.push_back(Point(cos(deg2rad( 35.0f)) * kSearchRadius,
                                         sin(deg2rad( 35.0f)) * kSearchRadius,
                                         kZval, egocentric));

            // forward
            searchPoints.push_back(Point(kSearchRadius, 0.0f, kZval, egocentric));

            // forward right
            searchPoints.push_back(Point(cos(deg2rad(-35.0f)) * kSearchRadius,
                                         sin(deg2rad(-35.0f)) * kSearchRadius,
                                         kZval, egocentric));

            // direct right
            searchPoints.push_back(Point(cos(deg2rad(-90.0f)) * kSearchRadius,
                                         sin(deg2rad(-90.0f)) * kSearchRadius,
                                         kZval, egocentric));
            
            // create a polygon, and have the robot look at the vertices of the polygon
            NEW_SHAPE(gazePoints, PolygonData, new PolygonData(localShS, searchPoints, false));
            mapreq.searchArea = gazePoints;
            mapreq.removePts = false;
        }

        $nodeclass PointHeadFwd : HeadPointerNode : doStart {
            // look ahead at point {x, y, z}
            getMC()->lookAtPoint(1400.0f, 0, 0);
        }

        $nodeclass OrganizeWorld : StateNode {

            virtual void doStart() {
                $reference KoduInterp::theWorld;
                std::cout << "[" << getName() << "]: organizing the world.\n";
                // get all the shapes that are probably false positives, or not considered as a
                // world shape, and remove them from the worldShS
                std::cout << "deleting some shapes.\n";
                NEW_SHAPEROOTVEC(shapesToDelete, subset(worldShS, Kodu::IsNotWorldShape()));
                worldShS.deleteShapes(shapesToDelete);
                // search for the north star
                std::cout << "searching for north star... ";
                NEW_SHAPEROOTVEC(constellation, subset(worldShS, Kodu::IsStar()));
                // check if the robot observed the constellation
                if (!constellation.empty()) {
                    std::cout << "found the North Star!\n";
                    // add the constellation (points) to the world state
                    theWorld->setStarConstellation(constellation);
                    // generate the world bounds
                    theWorld->generateWorldBoundsPolygon();
                    // remove the constellation from the world shape space (prevents the pilot from
                    // periodically stopping the robot---I want the interpreter to controll that)
                    worldShS.deleteShapes(constellation);
                } else {
                    std::cout << "could not find North Star (creating an artificial point)\n";
                    // nothing in the constellation was seen (generate the world bounds)
                    theWorld->generateWorldBoundsPolygon();
                }
                // set the world bounds in the pilot
                std::cout << "setting world bounds\n";
                VRmixin::pilot->setWorldBounds(theWorld->getWorldBoundsPolygon());
                // clear the landmark vector in the pilot
                std::cout << "clearing default landmarks\n";
                VRmixin::pilot->setDefaultLandmarks(std::vector<ShapeRoot>());
                postStateCompletion();
            }
        }

        $setupmachine {
            newWorld:       CreateWorld
            parse:          ParseKode
            look:           LookAround
            initArm:        ParkArm
            lookFwd:        PointHeadFwd
            orgWorld:       OrganizeWorld

            newWorld =C=> parse
            newWorld =F=> SpeechNode("error creating world") =C=> PostMachineFailure

            parse =S=> { look, initArm }
            parse =F=> PostMachineFailure

            look =C=> lookFwd =C=> orgWorld =C=> PostMachineCompletion
            initArm =C=> StateNode
        }
    }

    $nodeclass WalkMonitor : StateNode {
        $provide Kodu::PosOrientState lastRecordedState();

        virtual void doStart() {
            if (VRmixin::isWalkingFlag == true) {
                // get the robot's current state
                Kodu::PosOrientState currState(VRmixin::theAgent->getCentroid(),
                    VRmixin::theAgent->getOrientation());
                // get the difference between points and orientation
                Kodu::PosOrientState stateDiff = currState - lastRecordedState;
                // motion along the x-axis
                float xyNorm = stateDiff.position.xyNorm();
                // motion through turning
                float arcLen = std::fabs(stateDiff.orientation) * 130.0f;
                // increment the total distance travelled
                $reference KoduInterp::thisAgent;
                thisAgent->distanceTravelled = thisAgent->distanceTravelled + xyNorm + arcLen;
                lastRecordedState = currState;
                std::cout << "[" << getName() << "]: accumulated dist. = " 
                    << thisAgent->distanceTravelled << "mm\n";
            }
        }
    }

    $nodeclass VerifyObjectGrabbed : StateNode {

        $nodeclass LookAtTheGripper : MapBuilderNode(MapBuilderRequest::localMap) : doStart {
            std::cout << "[" << getName() << "]: looking at tag\n";
            mapreq.clearLocal = true;
            // search for an april tag
            mapreq.setAprilTagFamily();
            // look at the gripper
            fmat::Column<3> gripperLoc = kine->linkToBase(GripperFrameOffset).translation();
            NEW_SHAPE(gazePoint, PointData, new PointData(localShS,
                Point(gripperLoc[0], gripperLoc[1], gripperLoc[2], egocentric)));
            mapreq.searchArea = gazePoint;
        }

        $nodeclass VerifyObjectInGripper : StateNode : doStart {
            $reference KoduInterp::theWorld;
            $reference KoduInterp::thisAgent;
            std::cout << "[" << getName() << "]: verifying object was grabbed.\n";
            
            // check if a particular tag was seen
            NEW_SHAPE(tag, AprilTagData, find_if<AprilTagData>(localShS,
                Kodu::HasAprilTagID(theWorld->getTagIdForShape(
                    thisAgent->gripperObject.getId()))));
            
            // if the reference is not valid, post a failure
            if (!tag.isValid()) {
                std::cout << "NO TAGS WERE SEEN AT ALL!!!\n";
                postStateFailure();
                return;
            }

            //********** temp fix
            // 
            // get the gripper location
            fmat::Column<3> gripperLoc = kine->linkToBase(GripperFrameOffset).translation();
            Point gripperPoint(gripperLoc[0], gripperLoc[1], gripperLoc[2], egocentric);
            
            // check if the object is in the gripper
            if ((tag->getCentroid().xyDistanceFrom(gripperPoint) - 10.0f)
                < ShapeRootTypeConst(thisAgent->gripperObject, CylinderData)->getRadius())
            {
                std::cout << "successfully grabbed object\n";
                postStateSuccess();
            } else {
                std::cout << "failed to grab object... reattempting.\n";
                postStateFailure();
            }
            //***********
        }

        $nodeclass FindMissedObject : MapBuilderNode(MapBuilderRequest::localMap) : doStart {
            std::cout << "[" << getName() << "]: attempting to locate object (again)\n";
            // generate points to look at (near the robot's body)
            std::vector<Point> pts;
            pts.push_back(Point(  250,    0,    0, egocentric));
            pts.push_back(Point(  500,    0,    0, egocentric));
            pts.push_back(Point(  500, -200,    0, egocentric));
            pts.push_back(Point(  250, -200,    0, egocentric));
            NEW_SHAPE(gazePoints, PolygonData, new PolygonData(localShS, pts, false));
            
            // construct the mapbuilder request
            mapreq.searchArea = gazePoints;
            mapreq.setAprilTagFamily();
            mapreq.clearLocal = true;
        }

        $setupmachine {
            lookAtGripper:  LookAtTheGripper
            checkGripper:   VerifyObjectInGripper
            findObj:        FindMissedObject
            
            lookAtGripper =C=> checkGripper

            checkGripper =S=> PostMachineSuccess
            checkGripper =F=> findObj

            findObj =C=> PostMachineCompletion
            findObj =F=> SpeechNode("failure could not find a match") =C=> PostMachineFailure
        }
    }

    $nodeclass PerceptualMultiplexor : StateNode {
        $provide Kodu::PerceptualTaskBase* currentTask(NULL);
        $provide bool inRecovery(false);
        
        ~PerceptualMultiplexor() {
            currentTask = NULL;
        }

        enum MultiPlexorTransType_t {
            MPT_MAP_BUILDER = 0,
            MPT_PILOT
        };

        // Returns whether or not the perceptual multiplexor is in recovery mode
        bool isInRecovery() const {
            return inRecovery;
        }

        $nodeclass MultiplexorStart : StateNode {

            Kodu::PerceptualTaskBase* getNextExecutableTask() {
                $reference KoduInterp::theWorld;
                $reference KoduInterp::thisAgent;
                
                unsigned int tasksToExecute = thisAgent->ptasks.size();
                std::cout << "checking task #'s ";
                while (tasksToExecute > 0) {
                    std::cout << thisAgent->ptasks.front()->getTaskId() << "; ";
                    if (thisAgent->ptasks.front()->canExecute(*theWorld)) {
                        return thisAgent->ptasks.front();
                    }
                    tasksToExecute--;
                    thisAgent->ptasks.push(thisAgent->ptasks.front());
                    thisAgent->ptasks.pop();
                }
                std::cout << std::endl;
                return NULL;
            }

            virtual void doStart() {
                $reference KoduInterp::thisAgent;
                $reference PerceptualMultiplexor::currentTask;
                
                std::cout << "=== [" << getName() << "] ===\n";
                if (currentTask == NULL) {
                    if (thisAgent->ptasks.empty()) {
                        std::cout << "No tasks to execute; exiting.\n";
                        postParentCompletion();
                        return;
                    }
                
                    std::cout << thisAgent->ptasks.size() << " tasks to (possibly) execute!\n";
                    std::cout << "Getting next executable task...\n";
                    
                    if ((currentTask = getNextExecutableTask()) == NULL) {
                        std::cout << "no executable tasks left; exiting.\n";
                        postParentCompletion();
                        return;
                    }
                    // pop the current task off of the queue
                    thisAgent->ptasks.pop();
                }

                std::cout << "Executing task #" << currentTask->getTaskId() << " ";
                // check the task type to decide which task runner to use
                switch (currentTask->getType()) {
                    case Kodu::PT_VIS_BUMP_DETECTION:
                        std::cout << "(Bump Detection).\n";
                        postStateSignal<MultiPlexorTransType_t>(MPT_MAP_BUILDER);
                        return;

                    case Kodu::PT_VIS_GRIPPER_MONITOR:
                        std::cout << "(Gripper Monitor).\n";
                        postStateSignal<MultiPlexorTransType_t>(MPT_MAP_BUILDER);
                        return;

                    case Kodu::PT_VIS_LOCALIZATION:
                        std::cout << "(Localization).\n";
                        postStateSignal<MultiPlexorTransType_t>(MPT_PILOT);
                        return;

                    case Kodu::PT_VIS_WALK_PROGRESS:
                        std::cout << "(Walk Progress).\n";
                        postStateSignal<MultiPlexorTransType_t>(MPT_MAP_BUILDER);
                        return;

                    default:
                        std::cout << "MultiplexorStart: unidentified task found... exiting.\n";
                        postParentCompletion();
                        return;
                }
            }
        }

        /**
         * The state machine that:
         * 1) handles MapBuilder requests, and
         * 2) examines the results from the request
        **/
        $nodeclass MapBuilderTaskRunner : StateNode {

            $nodeclass ExecuteMapBuilderTask : MapBuilderNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                // (generate and) get the mapbuilder request
                mapreq = currentTask->getMapBuilderRequest();
            }

            $nodeclass ExamineMapBuilderResults : StateNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                // examine the results from the mapbuilder request
                currentTask->examineTaskResults();
                postParentCompletion();
            }

            $setupmachine {
                executeRequest:     ExecuteMapBuilderTask
                examineResults:     ExamineMapBuilderResults

                executeRequest =C=> examineResults
            }
        }

        // The PilotNode class used for executing Pilot request (such as localization)
        $nodeclass PilotTaskRunner : StateNode {

            $nodeclass ExecutePilotTask : PilotNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                std::cout << "[" << getName() << "]: submitting pilot request for localization\n";
                pilotreq = currentTask->getPilotRequest();
            }

            $nodeclass SetTaskSuccess : StateNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                std::cout << "[" << getName() << "]: setting pilot task status ==> SUCCESSFUL\n";
                currentTask->setTaskStatus(Kodu::PerceptualTaskBase::TS_SUCCESSFUL);
                NEW_SHAPEROOTVEC(stars, subset(worldShS, Kodu::IsStar()));
                worldShS.deleteShapes(stars);
                postParentCompletion();
            }

            $nodeclass SetTaskFailure : StateNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                std::cout << "[" << getName() << "]: setting pilot task status ==> FAILURE\n";
                currentTask->setTaskStatus(Kodu::PerceptualTaskBase::TS_FAILURE);
                NEW_SHAPEROOTVEC(stars, subset(worldShS, Kodu::IsStar()));
                worldShS.deleteShapes(stars);
                postParentCompletion();
            }

            $setupmachine {
                executeRequest:     ExecutePilotTask
                setTaskSuccess:     SetTaskSuccess
                setTaskFailure:     SetTaskFailure

                executeRequest =PILOT(noError)=> setTaskSuccess
                executeRequest =PILOT(cantLocalize)=> setTaskFailure
            }
        }
        
        $nodeclass MultiplexorEnd : StateNode : doStart {
            $reference KoduInterp::evaluatorRef;
            $reference KoduInterp::needToHaltExecution;
            $reference KoduInterp::theWorld;
            $reference KoduInterp::thisAgent;
            $reference PerceptualMultiplexor::currentTask;
            
            std::cout << "Task #" << currentTask->getTaskId() << " status: ";
            // check if the task is complete
            if (currentTask->taskIsComplete(*theWorld)) {
                std::cout << "complete! (removing task).\n";
                // check if the task failed
                if (currentTask->getStatus() == Kodu::PerceptualTaskBase::TS_FAILURE) {
                    $reference PerceptualMultiplexor::inRecovery;
                    inRecovery = true;
                    postStateFailure();
                    return;
                }
                // delete the task
                GeneralFncs::deletePtr(currentTask);
            }
            // else, the task is not complete so add it to the end of the queue
            else {
                std::cout << "NOT complete. (adding to end of queue).\n";
                thisAgent->ptasks.push(currentTask);
            }
            currentTask = NULL;
            // check if there are more tasks on the queue to execute
            if (thisAgent->ptasks.empty()) {
                // if there are more tasks, make the task at the front of the queue the current task
                std::cout << "exiting.\n";
                postParentCompletion();
            }
            // else, tell the parent state machine the multiplexor is done
            else {
                std::cout << "continuing to next task.\n";
                postStateCompletion();
            }
            // this means the evaluator was halted in order to recover, so restart the evaluator
            if (needToHaltExecution == true) {
                needToHaltExecution = false;
                evaluatorRef->start();
            }
        }

        $nodeclass FailureRecovery : StateNode {
            
            $nodeclass StartRecovery : StateNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                std::cout << "[" << getName() << "]\n";
                std::cout << "Perceptual Recovery starting...\n";
                // the signal type decides which recovery is started
                postStateSignal<Kodu::PerceptualTaskType_t>(currentTask->getType());
            }

            $nodeclass PauseEvaluator : StateNode : doStart {
                $reference KoduInterp::thisAgent;
                $reference KoduInterp::evaluatorRef;
                $reference KoduInterp::runnerRef;
                $reference KoduInterp::motionActRef;
                $reference KoduInterp::dropActRef;
                $reference KoduInterp::grabActRef;
                $reference KoduInterp::needToHaltExecution;
                
                std::cout << "[" << getName() << "]: pausing the evaluator.\n";
                static unsigned int waitCount = 0;
                
                // if the halt flag is not set (meaning it is false), set it to true
                if (needToHaltExecution == false) {
                    std::cout << "Requesting the evaluator to halt.\n";
                    needToHaltExecution = true;
                }
                
                // stop the drop action runner
                if (dropActRef->isActive()) {
                    std::cout << "Stopping the Grasper (drop action).\n";
                    dropActRef->stop();
                }

                // stop the grab action runner
                if (grabActRef->isActive()) {
                    std::cout << "Stopping the Grasper (grab action).\n";
                    grabActRef->stop();
                }

                // abort/stop any node that may use motion (e.g. Pilot, Grasper)
                if (thisAgent->isWalking()) {
                    std::cout << "Aborting current pilot request.\n";
                    VRmixin::pilot->pilotAbort();
                    thisAgent->agentIsWalking = false;
                    motionActRef->stop();
                }

                // make sure all are inactive before recovery proceeds
                if (!evaluatorRef->isActive() && !thisAgent->isWalking()
                    && !runnerRef->isActive() && !grabActRef->isActive())
                {
                    if ((++waitCount) == 2) {
                        waitCount = 0;
                        postStateCompletion();
                    }
                }
                // else, wait for the timeout transitions
                else {
                    PRINT_ATTRS("Evaluator is active?", evaluatorRef->isActive());
                    PRINT_ATTRS("Runner is active?", runnerRef->isActive());
                    PRINT_ATTRS("Agent is walking?", thisAgent->isWalking());
                    PRINT_ATTRS("Grab Action is active?", grabActRef->isActive());
                    waitCount = 0;
                }
            }

            $nodeclass ObjectManipRecovery : StateNode {
                $provide float const kReverseDist(75.0f);
                $provide Kodu::VisualGripperMonitorTask* gTask(NULL);
                $provide ShapeRoot grasperTarget;

                ~ObjectManipRecovery() {
                    gTask = NULL;
                }

                $nodeclass GetGripMonTask : StateNode : doStart {
                    std::cout << "[" << getName() << "]: getting the gripper monitor task\n";
                    $reference PerceptualMultiplexor::currentTask;
                    $reference ObjectManipRecovery::gTask;
                    // cast the current task, and point to it
                    gTask = static_cast<Kodu::VisualGripperMonitorTask*>(currentTask);
                    postStateCompletion();
                }

                $nodeclass OpenGripper : ArmNode : doStart {
                    std::cout << "[" << getName() << "]: opening the gripper\n";
                    // opens the gripper in case it detected a false positive (the object is
                    // still in the gripper, but the robot detected a failure)
                    getMC()->openGripper(1.0f);
                }

                $nodeclass Reverse : PilotNode(PilotTypes::walk) : doStart {
                    std::cout << "[" << getName() << "]: ";
                    $reference ObjectManipRecovery::gTask;
                    $reference ObjectManipRecovery::kReverseDist;
                    // get the current and last positions
                    Point lastPos = gTask->getLastSuccessfulState().position;
                    Point currPos = VRmixin::theAgent->getCentroid();
                    float additionalDist = (currPos - lastPos).xyNorm();
                    // if the robot travelled forward between the last and current points,
                    // include that distance
                    pilotreq.dx = (-1.0f * kReverseDist) - additionalDist;
                    std::cout << "reversing by " << std::fabs(pilotreq.dx) << "mm (" << kReverseDist
                        << " + " << additionalDist << ")\n";
                }

                $nodeclass LocateLostObject : MapBuilderNode(MapBuilderRequest::localMap) : doStart {
                    $reference ObjectManipRecovery::gTask;
                    std::cout << "[" << getName() << "]: creating mapbuilder request to find object\n";
                    // get the robot's state when it last saw the april tag in the correct location
                    Kodu::PosOrientState lastState = gTask->getLastSuccessfulState();
                    float lastOrient = lastState.orientation;
                    
                    // get the robot's current (position, orientation) state
                    Kodu::PosOrientState currState(VRmixin::theAgent->getCentroid(),
                       static_cast<float>(VRmixin::theAgent->getOrientation()));
                    float currOrient = currState.orientation;
                    
                    // get the difference between the last and current orientations
                    float orientDiff = AngTwoPi(lastOrient - currOrient);
                    std::cout << "currOrient = " << currOrient << " rads (= " << rad2deg(currOrient)
                        << " degs); lastOrient = " << lastOrient << " rads (= " << rad2deg(lastOrient)
                        << " degs); orientDiff = " << orientDiff << " rads (= " << rad2deg(orientDiff)
                        << " degs)\n";

                    const Shape<CylinderData>& lostCyl =
                        ShapeRootTypeConst(gTask->getGripperObject(), CylinderData);
                    
                    // create constants that will be used to tell the robot where to search
                    // the over approx. max reach the gripper has (measured from the robot's center)
                    float const kMaxGripperReach = 400.0f;
                    // the cylinder's height
                    float const kCylHeight = lostCyl->getHeight();
                    // the cylinder's radius
                    float const kCylRadius = lostCyl->getRadius();
                    // a fudge factor for the max search radius in case the calculation is a little off
                    float const kFudgeFactor = kCylRadius;
                    // the distance the robot reversed
                    $reference ObjectManipRecovery::kReverseDist;
                    // the max distance the robot should be away from the robot's centroid
                    float const kDropRadius = kMaxGripperReach + kCylRadius + kReverseDist;
                    // the max distance an object can be for the robot to consider it as the lost object
                    float const kMaxSearchRadius = kDropRadius + kCylRadius + kFudgeFactor;
                    
                    // find out what the robot was doing when the object fell out of the gripper
                    float const kInitAngle = gTask->getTagCentroid().atanYX();
                    float thetaIncrement = 0.0f;
                    float const kIncrementVal = deg2rad(15.0f);
                    if (std::fabs(lastOrient - currOrient) > M_PI) {
                        std::cout << "Robot crossed over the 360 deg mark (abs(orientDiff) = "
                            << std::fabs(lastOrient - currOrient) << ")\n";
                        if (currOrient < lastOrient) {
                            std::cout << "currOrient (" << currOrient << ") < lastOrient ("
                                << lastOrient << ")\n";
                            currOrient = currOrient + (2 * M_PI);
                        } else {
                            std::cout << "currOrient (" << currOrient << ") > lastOrient ("
                                << lastOrient << ")\n";
                            lastOrient = lastOrient + (2 * M_PI);
                        }
                        std::cout << "new values: currOrient = " << currOrient
                            << "; lastOrient = " << lastOrient << std::endl;
                    }
                    
                    float absOrientDiff = std::fabs(lastOrient - currOrient);
                    if (currOrient > lastOrient) {
                        thetaIncrement = -1.0f * kIncrementVal;
                        std::cout << "Robot was turning left between last successful state and now; ";
                    } else if (currOrient < lastOrient) {
                        thetaIncrement = kIncrementVal;
                        std::cout << "Robot was turning right between last successful state and now; ";
                    } else {
                        thetaIncrement = 0.0f;
                        std::cout << "The object should be in front of the gripper; ";
                    }
                    std::cout << "thetaIncrement = " << thetaIncrement << " rads (= "
                            << rad2deg(thetaIncrement) << " degs)\n";

                    // start from the current orientation and progressively look to the last state
                    std::vector<Point> pts;
                    int const kNumbOfPoints = static_cast<int>(std::ceil(absOrientDiff / kIncrementVal));
                    pts.reserve(kNumbOfPoints + 1);
                    std::cout << "the robot will have to look " << (kNumbOfPoints + 1) << " time(s).\n";
                    float currAngle = kInitAngle;
                    std::cout << "currAngle = " << currAngle << " rads (= " << (rad2deg(currAngle))
                        << " degs) ";
                    
                    // approx. position of the object if it was still in the gripper
                    pts.push_back(Point(cos(currAngle) * kDropRadius, sin(currAngle) * kDropRadius,
                        kCylHeight, egocentric));
                    std::cout << "begin pt = " << pts[0] << std::endl;

                    // generate the rest of the look points
                    for (int i = 0; i < kNumbOfPoints; i++) {
                        currAngle += thetaIncrement;
                        std::cout << "currAngle = " << currAngle << " rads (= "
                            << (rad2deg(currAngle)) << " degs) ";
                        pts.push_back(Point(cos(currAngle) * kDropRadius, sin(currAngle) * kDropRadius,
                            kCylHeight, egocentric));
                        std::cout << "added pt #" << pts.size() << " = " << pts[pts.size() - 1]
                            << std::endl;
                    }

                    // create the gaze polygon (the points the robot should look at)
                    NEW_SHAPE(objSearchPoints, PolygonData, new PolygonData(localShS, pts, false));
                    objSearchPoints->setViewable(true);
                    objSearchPoints->setObstacle(false);
                    
                    // create the mapbuilder request
                    mapreq.searchArea = objSearchPoints;
                    mapreq.clearLocal = true;
                    mapreq.maxDist = kMaxSearchRadius;
                    mapreq.pursueShapes = true;
                    mapreq.removePts = false;
                    mapreq.setAprilTagFamily();
                    mapreq.addObjectColor(lostCyl->getType(), lostCyl->getColor());
                }

                // ASSUMPTION: there is only one tag in view (need to use ID to select correct object)
                $nodeclass RetrieveLostObject : GrasperNode(GrasperRequest::grasp) : doStart {
                    $reference KoduInterp::theWorld;
                    $reference KoduInterp::thisAgent;
                    std::cout << "[" << getName() << "]: going to retrieve the lost object...\n";
                    
                    int tagId = theWorld->getTagIdForShape(thisAgent->gripperObject.getId());
                    ShapeRoot tag = find_if(localShS, Kodu::HasAprilTagID(tagId));

                    if (tag.isValid()) {
                        std::cout << "object is valid!\n";
                        $reference ObjectManipRecovery::grasperTarget;
                        // check if the grasper target is in the localShS or worldShS
                        if (!grasperTarget.isValid()) {
                            // create a vector of cylinders from the localShS
                            NEW_SHAPEROOTVEC(cyls, subset(localShS,
                                Kodu::IsShapeOfType(cylinderDataType)));
                            // look for the cylinder closest to the april tag
                            grasperTarget = Kodu::getClosestObjectToPoint(cyls, tag->getCentroid());
                            // import that cylinder into the world shape space
                            grasperTarget = VRmixin::mapBuilder->importLocalShapeToWorld(grasperTarget);
                        }
                        graspreq.object = grasperTarget;
                        graspreq.allowBodyMotion = false;
                    } else {
                        std::cout << "object is NOT valid!!!\n";
                        cancelThisRequest();
                    }
                }

                $nodeclass RepositionBody : PilotNode(PilotTypes::walk) : doStart {
                    $reference KoduInterp::theWorld;
                    $reference ObjectManipRecovery::grasperTarget;
                    std::cout << "[" << getName() << "]: reversing by ";

                    // get a particular april tag
                    int tagId = theWorld->getTagIdForShape(theWorld->thisAgent.gripperObject.getId());
                    ShapeRoot tag = find_if(localShS, Kodu::HasAprilTagID(tagId));

                    // get the gripper location
                    fmat::Column<3> gripperLoc = kine->linkToBase(GripperFrameOffset).translation();
                    Point gripperPoint(gripperLoc[0], gripperLoc[1], gripperLoc[2], egocentric);
                    // if the tag is nearer to the body than the gripper, reverse by the
                    // difference between the tag's and gripper's centroids
                    if (tag->getCentroid().coordX() < gripperPoint.coordX()) {
                        pilotreq.dx = -1.0f * (gripperPoint.coordX() - tag->getCentroid().coordX());
                    }
                    // reverse by 1.5x the radius of the cylinder
                    float radius = ShapeRootTypeConst(grasperTarget, CylinderData)->getRadius();
                    pilotreq.dx = pilotreq.dx - (1.5f * radius);
                    std::cout << std::fabs(pilotreq.dx) << "mm)\n";
                    
                    // reposition the gripper target object
                    const Point& kTagCen = tag->getCentroid();
                    Point objFutureEgoPos(std::fabs(pilotreq.dx) + kTagCen.coordX(), kTagCen.coordY(),
                                          kTagCen.coordZ() / 2.0f, egocentric);
                    objFutureEgoPos.applyTransform(VRmixin::mapBuilder->localToWorldMatrix, allocentric);
                    std::cout << "Repositioning the object to from "
                        << grasperTarget->getCentroid() << " to " << objFutureEgoPos
                        << std::endl;
                    grasperTarget->setPosition(objFutureEgoPos);
                    postStateCompletion();
                }

                // ASSUMPTION: only one tag is in view
                $nodeclass GetTagLocation : StateNode : doStart {
                    $reference KoduInterp::theWorld;
                    $reference ObjectManipRecovery::gTask;
                    std::cout << "[" << getName() << "]: getting april tag's location...\n";

                    int tagId = theWorld->getTagIdForShape(theWorld->thisAgent.gripperObject.getId());
                    ShapeRoot objtag = find_if(localShS, Kodu::HasAprilTagID(tagId));

                    if (objtag.isValid()) {
                        std::cout << "repositioning tag's location to " << objtag->getCentroid()
                            << std::endl;
                        gTask->relocateTagCentroid(objtag->getCentroid());
                        std::cout << "changing task status to IN PROGRESS\n";
                        gTask->setTaskStatus(Kodu::PerceptualTaskBase::TS_IN_PROGRESS);
                        postStateSuccess();
                    } else {
                        std::cout << "object tag is NOT VALID!!!\n";
                        postStateFailure();
                    }
                    // book keeping
                    gTask = NULL;
                    //********** possible temp fix
                    $reference ObjectManipRecovery::grasperTarget;
                    std::cout << "grasper target valid? ";
                    if (grasperTarget.isValid()) {
                        std::cout << "yes\n";
                        std::cout << "grasper target's matches the gripper target?";
                        $reference KoduInterp::thisAgent;
                        if (grasperTarget.getId() == thisAgent->gripperObject.getId()) {
                            std::cout << "yes, not deleting... making it not an obstacle.\n";
                            grasperTarget->setObstacle(false);
                        } else {
                            std::cout << "no, deleting the object.\n";
                            worldShS.deleteShape(grasperTarget);
                        }
                    } else {
                        std::cout << "no, THIS SHOULD NOT HAPPEN!!!\n";
                    }
                    //***********
                }

                $setupmachine {
                    pause:      PauseEvaluator
                    getTask:    GetGripMonTask
                    openGrip:   OpenGripper
                    rvrs:       Reverse
                    find:       LocateLostObject
                    retrv:      RetrieveLostObject
                    
                    verify:     VerifyObjectGrabbed
                    posBody:    RepositionBody

                    getLoc:     GetTagLocation

                    pause =T(300)=> pause
                    pause =C=> getTask =C=> openGrip =C=> rvrs =C=> find =C=> retrv =GRASP=> verify
                    
                    //retrv =GRASP(noError)=> LookAtGripper =C=> look =C=> getLoc
                    //retrv =GRASP(someError)=> SpeechNode("recovery failed") =C=> PostMachineFailure

                    verify =S=> getLoc
                    verify =C=> posBody =C=> retrv
                    verify =F=> SpeechNode("recovery failure") =F=> PostMachineFailure
                    
                    getLoc =S=> PostMachineSuccess
                    getLoc =F=> PostMachineFailure
                }

            private:
                DISALLOW_COPY_ASSIGN(ObjectManipRecovery);
            }

            $nodeclass WalkRecovery : StateNode {

                $nodeclass CreateLocalizeTask : StateNode : doStart {
                    $reference PerceptualMultiplexor::currentTask;
                    $reference KoduInterp::theWorld;
                    std::cout << "[" << getName() << "]\n";
                    std::cout << "Deleting task #" << currentTask->getTaskId() << std::endl;
                    // remove old walk progress task
                    GeneralFncs::deletePtr(currentTask);
                    // make the localization task the new current task
                    std::cout << "Creating a localization task\n";
                    currentTask = new Kodu::VisualLocalizationTask(theWorld->getStarConstellation());
                    postParentCompletion();
                }

                $setupmachine {
                    pause:      PauseEvaluator
                    createTask: CreateLocalizeTask
                    
                    pause =C=> SpeechNode("localizing") =C=> createTask
                    pause =T(300)=> pause
                }
            }

            $nodeclass EndRecovery : StateNode : doStart {
                $reference PerceptualMultiplexor::inRecovery;
                std::cout << "[" << getName() << "]: ending recovery...\n";
                inRecovery = false;
                postParentCompletion();
            }

            $setupmachine {
                startRec:   StartRecovery
                //************* temp fix
                //locRec:     LocalizeRecovery
                //*************
                manipRec:   ObjectManipRecovery
                walkRec:    WalkRecovery
                endRec:     EndRecovery

                //startRec =S<Kodu::PerceptualTaskType_t>(Kodu::PT_VIS_LOCALIZATION)=> locRec
                startRec =S<Kodu::PerceptualTaskType_t>(Kodu::PT_VIS_GRIPPER_MONITOR)=> manipRec
                startRec =S<Kodu::PerceptualTaskType_t>(Kodu::PT_VIS_WALK_PROGRESS)=> walkRec
                
                //************* temp fix
                bumpRec: SpeechNode("unhandled recovery for bump detection")
                startRec =S<Kodu::PerceptualTaskType_t>(Kodu::PT_VIS_BUMP_DETECTION)=> bumpRec
                //*************

                //************* temp fix
                //locRec =C=> endRec
                //locRec =F=> SpeechNode("failed to do localization using global gaze polygon")
                //*************
                
                manipRec =S=> endRec
                //*********** temp fix
                manipRec =F=> SpeechNode("unhandled failure recovery for manipulation")
                //***********

                walkRec =C=> endRec
            }
        }

        $setupmachine {
            startMP:        MultiplexorStart
            runMBTask:      MapBuilderTaskRunner
            runPilotTask:   PilotTaskRunner
            endMP:          MultiplexorEnd
            recovery:       FailureRecovery

            startMP =S<MultiPlexorTransType_t>(MPT_MAP_BUILDER)=> runMBTask
            startMP =S<MultiPlexorTransType_t>(MPT_PILOT)=> runPilotTask

            runMBTask =C=> endMP
            runPilotTask =C=> endMP

            endMP =C=> startMP
            endMP =F=> recovery

            recovery =C=> startMP
        }

        private:
            DISALLOW_COPY_ASSIGN(PerceptualMultiplexor);
    }
    
    //! 
    $nodeclass KoduConditionEvaluator : StateNode {
        $provide unsigned int cycleCount(0);

        //! Enables child rules with the once modifier enabled (who have already ran) to run (again)
        void resetChildRulesWithOnceEnabled(const unsigned int kParentRuleNumer) {
            $reference KoduInterp::thisAgent;

            Kodu::KoduPage* page = thisAgent->getCurrentPage();
            Kodu::KoduRule* rule = NULL;
            const int kRuleCount = page->getRuleCount();
            for (int childRule_i = kParentRuleNumer + 1; childRule_i < kRuleCount; childRule_i++) {
                // get rule# i
                rule = page->getRule(childRule_i);
                // check if this rule's parent is kParentRuleNumber
                // if it is, set actionCanRun flag to true
                // else break--this rule has no more child actions
                if (rule->getParentNumber() == kParentRuleNumer)
                    rule->action->setAgentCanUsePrimitive(true);
                else
                    break;
            }
            page = NULL;
            rule = NULL;
        }

        virtual void doStart() {
            $reference KoduInterp::multiplexorRef;
            $reference KoduInterp::needToHaltExecution;
            $reference KoduInterp::theWorld;
            $reference KoduInterp::thisAgent;

            std::cout << "\n=== [Kodu Condition Evaluator] ===\n";
            // check if the evaluator needs to halt execution
            if (needToHaltExecution) {
                std::cout << "halting evaluator execution\n";
                postStateFailure();
                return;
            }

            // pointers to the current page, rule, condition, and action (respectively)
            Kodu::KoduPage* page;
            Kodu::KoduRule* rule;
            Kodu::KoduCondition* cond;
            Kodu::KoduAction* act;
            // check if the current page is NULL
            if ((page = thisAgent->getCurrentPage()) == NULL) {
                std::cerr << "!!! A NULL page was found.\n";
                postStateFailure();
                return;
            }
            // print the current game cycle and page number
            std::cout << "GAME CYCLE #" << cycleCount++ << ", PAGE #" << page->getPageNumber() << "\n";
            // check if there are rules on this page
            const int numbOfRules = page->getRuleCount();
            if (numbOfRules == 0) {
                std::cout << "Reached an empty page. Stopping interpreter...\n";
                postStateFailure();
                return;
            }
            // iterate over all the rules of a page
            for (int i = 0; i < numbOfRules; i++) {
                // checks if the rule returned is NULL. 
                if ((rule = page->getRuleInPos(i)) == NULL) {
                    std::cerr << "!!! A NULL rule was found. Tried accessing Page["
                              << (page->getPageNumber() - 1) << "], Rule[" << i << "]\n";
                    postStateFailure();
                    return;
                }
                
                // the parent ID and rule ID of the current rule (respectively)
                const unsigned int kParentId = rule->getParentNumber();
                const unsigned int kRuleId = rule->getRuleNumber();

                // check if this rule has parent rule and if its condition evaluated true
                if (rule->isIndented() && page->getRule(kParentId)->condLastEvalResult == false) {
                    rule->condLastEvalResult = false;
                    continue;
                }
                
                // point to the current condition and action
                cond = rule->condition;
                act = rule->action;
                
                // check if the agent can evaluate the condition
                if (!cond->agentCanUsePrimitive()) {
                    std::cout << "cannot evaluate condition... continuing.\n";
                    continue;
                }
                
                // TODO (05/July/2013) Figure out how to cancel a running pilot request
                if (cond->evaluate(*theWorld) == true) {
                    // resets the action has already ran flag
                    if (rule->condLastEvalResult == false) {
                        resetChildRulesWithOnceEnabled(kRuleId);
                    }
                    
                    // states condition evaluated true (no matter if action can execute or not)
                    rule->setConditionEvalResult(true);
                    
                    // check if the action can run
                    if (!(act->agentCanUsePrimitive())) {
                        continue;
                    }
                    // check if this action:
                    // 1) [implicit] can use the once modifier, and
                    // 2) has the once modifier enabled
                    if (act->onceModIsEnabled()) {
                        act->setAgentCanUsePrimitive(false);
                    }
                    
                    // check the action type
                    std::cout << "checking actions: ";
                    switch(act->getActionType()) {
                        // Kodu Action Do Nothing
                        case Kodu::KoduAction::AT_DO_NOTHING:
                        {
                            std::cout << "Do nothing.\n";
                            break;
                        }

                        // Kodu Action Drop
                        case Kodu::KoduAction::AT_DROP:
                        {
                            std::cout << "drop; ";
                            // a drop action can only execute if the agent is:
                            // 1) holding an object,
                            // 2) not executing another manipulation action
                            // 3) not executing a motion action
                            if (thisAgent->isHoldingAnObject() && !thisAgent->isExecutingManipAction()
                                && !thisAgent->isWalking())
                            {
                                std::cout << "Agent wants to drop item.\n";
                                // signal that a drop action is executing (prevents any motion or 
                                // other manipulation actions from executing)
                                thisAgent->signalDropActionStart();
                            }
                            break;
                        }

                        // Kodu Action Grab
                        case Kodu::KoduAction::AT_GRAB:
                        {
                            std::cout << "grab; ";
                            // a grab action can only execute if the agent is:
                            // 1) not executing a motion action,
                            // 2) not executing another manipulation action
                            // 3) the target shape is valid
                            // 4) the target shapes is not the same shape in the gripper
                            if (!thisAgent->isWalking() && !thisAgent->isExecutingManipAction()) {
                                // get the target object
                                ShapeRoot targetObject =
                                    static_cast<Kodu::KoduActionGrab*>(act)->getTargetObject();
                                
                                if (targetObject.isValid() && targetObject != thisAgent->gripperObject)
                                {
                                    // signal that a grab action wants to execute (prevents any motion
                                    // or other manipulation actions from executing)
                                    thisAgent->signalGrabActionStart();
                                    thisAgent->gripperObject = targetObject;
                                    std::cout << "Selected an object " << targetObject
                                        << " to be grabbed.\n";
                                }
                            }
                            break;
                        }

                        // Kodu Action Motion
                        case Kodu::KoduAction::AT_MOTION:
                        {
                            std::cout << "motion; ";
                            // get the current motion command
                            Kodu::MotionCommand cmd =
                                static_cast<Kodu::KoduActionMotion*>(act)->getMotionCommand();
                            
                            // TODO
                            // should the interpreter check if the robot is executing a manip action here
                            // or in the action runner node?
                            if (!thisAgent->isWalking() && !thisAgent->hasMotionCommand()
                                && cmd.isValid())
                            {
                                thisAgent->currMotionCmd = cmd;
                                if (cmd.targetObjectIsValid()) {
                                    thisAgent->ptasks.push(
                                        new Kodu::VisualWalkProgressTask(cmd.getTargetObject()));
                                }
                                std::cout << "Added a motion command.\n";
                            }
                            break;
                        }

                        // Kodu Action Page Switch
                        case Kodu::KoduAction::AT_PAGE_SWITCH:
                        {
                            std::cout << "page switch; ";
                            // get the new requested page number (agent will switch to it immediately)
                            if (!thisAgent->hasNewPageNumber()) {
                                thisAgent->newReqdPage =
                                    static_cast<Kodu::KoduActionPageSwitch*>(act)->getPageNumber();
                                std::cout << "Switching to another page!\n";
                            }
                            break;
                        }

                        // Kodu Action Play
                        case Kodu::KoduAction::AT_PLAY:
                        {
                            std::cout << "play; ";
                            // get the sound file
                            std::string soundFile =
                                static_cast<Kodu::KoduActionPlay*>(act)->getSoundFile();
                            // add the sound file to the play queue
                            thisAgent->playQueue.push(soundFile);
                            std::cout << "Added the sound file \"" << soundFile << "\".\n";
                            break;
                        }

                        // Kodu Action Say
                        case Kodu::KoduAction::AT_SAY:
                        {
                            std::cout << "say; ";
                            // make sure the agent does not have anything to say first
                            if (!thisAgent->hasTextToSay()) {
                                // give the string to the agent
                                thisAgent->stringToSpeak =
                                    static_cast<Kodu::KoduActionSay*>(act)->getStringToSpeak();
                                std::cout << "Added literal string: \""
                                    << thisAgent->stringToSpeak << "\".\n";
                            }
                            break;
                        }

                        // Kodu Action Score
                        case Kodu::KoduAction::AT_SCORING:
                        {
                            std::cout << "score; ";
                            // add the score change to the score queue
                            thisAgent->scoreQueue.push(
                                static_cast<Kodu::KoduActionScore*>(act)->getScoreChange());
                            std::cout << "Added a score action type.\n";
                            break;
                        }

                        default:
                        {
                            std::cerr << "Unrecognized action: \""
                                  << act->getPrimitiveType() << "\"\n";
                            break;
                        }
                    }
                    // check if the agent needs to switch pages
                    if (thisAgent->hasNewPageNumber())
                        break;
                } else {
                    // states rule evaluated false
                    rule->setConditionEvalResult(false);
                    // check the condition type...
                    // if it is not a timer condition, then set the "action can run" flag to true
                    if (!cond->getConditionType() != Kodu::KoduCondition::CT_TIMER) {
                        act->setAgentCanUsePrimitive(true);
                    }
                    /**
                     * check if the condition is type KoduConditionBump
                     * if so, stop evaluating the condition, and create a perceptual task for it.
                     * once the robot is close enough to detect a bump, the task will visually detect
                     * bump. if the detection was successful, the agent would be able to evaluate the
                     * rule again. if not, the rule is disabled for some time (temp fix)
                    **/
                    if (cond->getConditionType() == Kodu::KoduCondition::CT_BUMP
                        && !thisAgent->isExecutingManipAction())
                    {
                        thisAgent->ptasks.push(new Kodu::VisualBumpDetectionTask(
                            static_cast<Kodu::KoduConditionBump*>(cond), theWorld));
                    }
                }
                // invalidate object
                Kodu::ObjectKeeper::isValid = false;
                cond = NULL;
                act = NULL;
            }
            page = NULL;
            rule = NULL;
            PRINT_ATTRS("P-Task queue empty?", thisAgent->ptasks.empty());
            PRINT_ATTRS("Multiplexor active?", multiplexorRef->isActive());
            if (!thisAgent->ptasks.empty() && !multiplexorRef->isActive()){
                std::cout << "starting multiplexor...\n";
                multiplexorRef->start();
            }

            postStateCompletion();
        }
    } // end of Kodu Interpreter

    //! Kodu Action Runner
    $nodeclass KoduActionRunner : StateNode : doStart {
        $reference KoduInterp::thisAgent;
        $reference KoduInterp::dropActRef;
        $reference KoduInterp::grabActRef;
        $reference KoduInterp::motionActRef;
        $reference KoduInterp::pageSwitchActRef;
        $reference KoduInterp::playActRef;
        $reference KoduInterp::sayActRef;
        $reference KoduInterp::scoreActRef;
        
        std::cout << "=== [Kodu Action Runner] ===\n";
        if (thisAgent->wantsToDropObject())
            dropActRef->start();

        if (thisAgent->wantsToGrabObject())
            grabActRef->start();

        if (thisAgent->hasMotionCommand() && !thisAgent->hasNewPageNumber()
            && !thisAgent->isExecutingManipAction())
        {
            motionActRef->start();
        }

        if (thisAgent->hasSoundsToPlay())
            playActRef->start();
        
        if (thisAgent->hasTextToSay())
            sayActRef->start();
            
        if (thisAgent->hasNewScoreChanges())
            scoreActRef->start();

        if (thisAgent->hasNewPageNumber())
            pageSwitchActRef->start();
    }

// ================================ Action Handlers ========================================= //

// DropActionRunner

    $nodeclass DropActionRunner : StateNode {
        $provide Kodu::VisualGripperMonitorTask* gTask(NULL);

        ~DropActionRunner() {
            gTask = NULL;
        }

        $nodeclass DropActionStart : StateNode : doStart {
            std::cout << "[" << getName() << "]: initiating drop action.\n";
            std::cout << "Searching for the gripper monitor task.\n";
            // locate the gripper monitor task
            $reference KoduInterp::thisAgent;
            $reference DropActionRunner::gTask;
            gTask = NULL;
            unsigned int tasksToExecute = thisAgent->ptasks.size();
            while (tasksToExecute > 0) {
                if (thisAgent->ptasks.front()->getType() == Kodu::PT_VIS_GRIPPER_MONITOR) {
                    gTask = static_cast<Kodu::VisualGripperMonitorTask*>(thisAgent->ptasks.front());
                    thisAgent->ptasks.pop();
                } else {
                    thisAgent->ptasks.push(thisAgent->ptasks.front());
                    thisAgent->ptasks.pop();
                }
                tasksToExecute--;
            }

            // should never happen, but just in case...
            if (gTask == NULL) {
                std::cout << "THIS IS A SERIOUS ERROR!!!---the gripper task should not be null!\n";
                postStateFailure();
                return;
            }
            std::cout << "GripMonTask id = " << gTask->getTaskId() << std::endl;
            postStateCompletion();
        }

        $nodeclass ExecuteDrop : StateNode {
            $provide Point objFutureEgoPos;
            $provide float kReverseDist(120.0f);

            $nodeclass DropItem : ArmNode : doStart {
                std::cout << "[" << getName() << "]: releasing the item.\n";
                // open the gripper
                getMC()->openGripper(1.0f);
            }

            $nodeclass LookAtObjectAprilTag : MapBuilderNode(MapBuilderRequest::localMap) : doStart {
                std::cout << "[" << getName() << "]: looking for released object's april tag\n";
                $reference DropActionRunner::gTask;
                // create a mapbuilder request to locate the april tag one more time.
                // will be used to identify the correct object if more than one are in view
                // once the object is released.
                mapreq.setAprilTagFamily();
                NEW_SHAPE(gazePoint, PointData, new PointData(localShS, gTask->getTagCentroid()));
                mapreq.searchArea = gazePoint;
                mapreq.clearLocal = true;
            }

            $nodeclass RecordAprilTagPos : StateNode : doStart {
                std::cout << "[" << getName() << "]: attempting to record april tag's position.\n";
                // find the object's april tag position and log it
                $reference DropActionRunner::gTask;
                NEW_SHAPE(objTag, AprilTagData, find_if<AprilTagData>(localShS,
                    Kodu::HasAprilTagID(gTask->getTagId())));
                // check if the shape is valid (that means the tag was found)
                if (objTag.isValid()) {
                    $reference KoduInterp::thisAgent;
                    $reference ExecuteDrop::objFutureEgoPos;
                    $reference ExecuteDrop::kReverseDist;
                    std::cout << "found the tag @ " << objTag->getCentroid() << "; logging it\n";
                    const Point& kTagCurrPos = objTag->getCentroid();
                    const float kCylHeight
                        = ShapeRootTypeConst(thisAgent->gripperObject, CylinderData)->getHeight();
                    objFutureEgoPos = Point(kTagCurrPos.coordX() + kReverseDist, kTagCurrPos.coordY(),
                                            (kCylHeight / 2.0f), egocentric);
                    postStateSuccess();
                }
                // else, report an error... lighting could be an issue if this did happen though
                else {
                    std::cout << "DID NOT FIND THE APRIL TAG!!!\n";
                    postStateFailure();
                }
            }

            $nodeclass ReverseBody : PilotNode(PilotTypes::walk) : doStart {
                std::cout << "[" << getName() << "]: reversing body by ";
                $reference ExecuteDrop::kReverseDist;
                pilotreq.dx = -1.0f * kReverseDist;
                std::cout << pilotreq.dx << "mm\n";
            }

            $nodeclass LocalizeAgent(unsigned int numbOfStarsRequested) : PilotNode : doStart {
                std::cout << "[" << getName() << "]: attempting to localize\n";
                $reference KoduInterp::theWorld;
                // create a localization task, and execute it before adding the shape in the world
                Kodu::VisualLocalizationTask localizeTask(theWorld->getStarConstellation(),
                                                          numbOfStarsRequested);
                pilotreq = localizeTask.getPilotRequest();
            }

            $nodeclass RepositionReleasedObject : StateNode {

                $nodeclass LookForObjectAgain : MapBuilderNode(MapBuilderRequest::localMap) : doStart {
                    std::cout << "[" << getName() << "]: looking for object again\n";
                    $reference KoduInterp::thisAgent;
                    $reference ExecuteDrop::objFutureEgoPos;
                    // create the point the agent should look at
                    NEW_SHAPE(gazePoint, PointData, new PointData(localShS, objFutureEgoPos));
                    const float kCylRadius
                        = ShapeRootTypeConst(thisAgent->gripperObject, CylinderData)->getRadius();

                    // construct the mapbuilder request
                    mapreq.addAttributes(thisAgent->gripperObject);
                    mapreq.searchArea = gazePoint;
                    mapreq.maxDist = objFutureEgoPos.xyNorm() + (kCylRadius * 2.0f);
                    mapreq.pursueShapes = true;
                    mapreq.clearLocal = true;
                }

                $nodeclass RepositionObject : StateNode : doStart {
                    std::cout << "[" << getName() << "]: attempting to 'reposition' the object\n";
                    $reference KoduInterp::thisAgent;
                    $reference ExecuteDrop::objFutureEgoPos;
                    // get all the shapes that are the same type as the object in the gripper
                    ShapeType_t objType = thisAgent->gripperObject->getType();
                    std::vector<ShapeRoot> localShapes(localShS.allShapes(objType));

                    // should not ever happen, but just in case...
                    if (localShapes.empty()) {
                        std::cout << "THIS IS A SERIOUS ERROR!\n";
                        postStateFailure();
                        return;
                    }

                    // get the closest object to the precalculated point
                    ShapeRoot closestMatch = Kodu::getClosestObjectToPoint(localShapes, objFutureEgoPos);
                    // apply tranformation to closest match (egocentric --> allocentric)
                    Point closestMatchPt(closestMatch->getCentroid());
                    closestMatchPt.applyTransform(VRmixin::mapBuilder->localToWorldMatrix, allocentric);
                    std::cout << "Repositioning the object to from "
                        << thisAgent->gripperObject->getCentroid() << " to "
                        << closestMatchPt << std::endl;
                    
                    // reposition the gripper object
                    thisAgent->gripperObject->setPosition(closestMatchPt);
                    thisAgent->gripperObject = ShapeRoot();
                    postStateSuccess();
                }

                $setupmachine {
                    lookAgain:      LookForObjectAgain
                    reposition:     RepositionObject

                    lookAgain =C=> reposition =S=> PostMachineSuccess
                    reposition =F=> SpeechNode("could not find any local shapes") =C=> PostMachineFailure
                }
            }

            $setupmachine {
                drop:        DropItem
                lookAtTag:   LookAtObjectAprilTag
                recordATPos: RecordAprilTagPos
                reverse:     ReverseBody
                parkArm:     ParkArm
                localize2:   LocalizeAgent(Kodu::VisualLocalizationTask::kMinStarsRequiredToLocalize)
                localize3:   LocalizeAgent(Kodu::VisualLocalizationTask::kMinStarsRequiredToLocalize + 1)
                attempRepos: RepositionReleasedObject

                drop =C=> lookAtTag =C=> recordATPos =S=> reverse =C=> { localize2, parkArm }
                drop =F=> SpeechNode("error occurred while dropping object") =C=> PostMachineFailure

                recordATPos =F=> SpeechNode("could not record the tag position") =C=> PostMachineFailure

                localize2 =PILOT(noError)=> attempRepos
                localize2 =PILOT(cantLocalize)=> localize3

                parkArm =C=> StateNode

                localize3 =PILOT(noError)=> attempRepos
                localize3 =PILOT(cantLocalize)=> SpeechNode("localize failed") =C=> PostMachineFailure

                attempRepos =S=> PostMachineSuccess
                attempRepos =F=> PostMachineFailure
            }
        }

        $nodeclass DropActionEnd : StateNode : doStart {
            $reference KoduInterp::thisAgent;
            $reference DropActionRunner::gTask;
            // delete the gripper monitor task
            GeneralFncs::deletePtr(gTask);
            // states the object is no longer in the gripper, and release the hold on
            // executing manipulation actions (and implicitly motion too)
            thisAgent->manipulationComplete();
            postStateCompletion();
        }

        $setupmachine {
            dStart:     DropActionStart
            exec:       ExecuteDrop
            dEnd:       DropActionEnd

            dStart =C=> exec

            exec =S=> dEnd
            exec =F=> SpeechNode("failure during drop execution") =C=> dEnd

            dEnd =C=> PostMachineCompletion
        }

    private:
        DISALLOW_COPY_ASSIGN(DropActionRunner);
    }

// GrabActionRunner

    $nodeclass GrabActionRunner : StateNode {
        $provide int objectTagId(-1);
        
        $nodeclass GrabActionStart : StateNode {

            // first check if the agent is near enough to the object
            $nodeclass IsObjectNear : StateNode : doStart {
                $reference KoduInterp::thisAgent;
                std::cout << "[" << getName() << "]: is agent near object? ";
                if (Kodu::distanceInBetweenAgentAndObject(thisAgent->gripperObject)
                    < Kodu::KoduConditionBump::kMaxDistanceAwayToSenseBump)
                {
                    std::cout << "yes, it is!\n";
                    postStateSuccess();
                } else {
                    std::cout << "no, it is not. making gripperObject reference invalid.\n";
                    thisAgent->gripperObject = ShapeRoot();
                    postStateFailure();
                }
            }

            /**
             * ASSUMPTIONS:
             *  - the object was bumped before this action was executed.
            **/
            $nodeclass GetTagId : StateNode : doStart {
                std::cout << "[" << getName() << "]: getting tag id. (id = ";
                $reference KoduInterp::theWorld;
                $reference GrabActionRunner::objectTagId;
                // if the {world shape id, tag id} pair exists, log the tag id
                if (theWorld->shapeTagPairExists(theWorld->thisAgent.gripperObject.getId())) {
                    objectTagId = theWorld->getTagIdForShape(theWorld->thisAgent.gripperObject.getId());
                }
                std::cout << objectTagId << ").\n";
                std::cout << "target id = " << theWorld->thisAgent.gripperObject.getId() << std::endl;
                postStateCompletion();
            }

            $setupmachine {
                isNear:         IsObjectNear
                getTagId:       GetTagId

                isNear =S=> getTagId =C=> PostMachineSuccess
                isNear =F=> PostMachineFailure
            }
        } // end of GrabActionStart

        /**
         * Positions the body so that the robot can grab the object
         * ASSUMPTIONS:
         *  - the item is graspable, and there is nothing in between the agent and the target object
        **/
        $nodeclass PrepareBody : StateNode {

            /**
             * Face the object.
             * ASSUMPTIONS:
             * - the arm is parked
            **/
            $nodeclass FaceObject : PilotNode(PilotTypes::walk) : doStart {
                $reference KoduInterp::thisAgent;
                std::cout << "[" << getName() << "]: turning towards object\n";
                pilotreq.da = Kodu::bearingFromAgentToObject(thisAgent->gripperObject);
            }

            /**
             * Reverse the body so the arm has enough space to swivel without hitting the object
             * ASSUMPTIONS:
             *  - the arm's length is less than or equal to kArmMaxLength
            **/
            $nodeclass ReverseBody : PilotNode(PilotTypes::walk) : doStart {
                $reference KoduInterp::thisAgent;
                std::cout << "[" << getName() << "]: reversing body ";
                float const kArmMaxLength = 210.0f;
                float distInBtwObjects = Kodu::distanceInBetweenAgentAndObject(thisAgent->gripperObject);
                pilotreq.dx = -1.0f * kArmMaxLength;
                std::cout << std::fabs(pilotreq.dx) << "mm (" << kArmMaxLength << " + "
                    << distInBtwObjects << ")\n";
            }

            $setupmachine {
                face:   FaceObject
                rvrs:   ReverseBody

                face =C=> rvrs =C=> PostMachineCompletion
            }
        } // end of PrepareBody

        $nodeclass ExecuteGrabAction : StateNode {
            
            /**
             * Attempt to grab the object
             * ASSUMPTIONS:
             *  - the robot's arm will not hit the object (the PrepareBody state machine worked)
            **/
            $nodeclass GrabObject : GrasperNode(GrasperRequest::grasp) : doStart {
                $reference KoduInterp::thisAgent;
                std::cout << "[" << getName() << "]: attempting to grab " << thisAgent->gripperObject
                    << std::endl;
                // set the gripper object as the target for the grasp request
                graspreq.object = thisAgent->gripperObject;
                // prevent the robot from moving away from the target shape
                graspreq.allowBodyMotion = false;
            }

            $nodeclass RepositionBody : PilotNode(PilotTypes::walk) : doStart {
                $reference KoduInterp::theWorld;
                $reference GrabActionRunner::objectTagId;
                std::cout << "[" << getName() << "]: reversing by ";

                // get a particular april tag
                ShapeRoot tag = find_if(localShS, Kodu::HasAprilTagID(objectTagId));

                // get the gripper location
                fmat::Column<3> gripperLoc = kine->linkToBase(GripperFrameOffset).translation();
                Point gripperPoint(gripperLoc[0], gripperLoc[1], gripperLoc[2], egocentric);
                // if the tag is nearer to the body than the gripper, reverse by the
                // difference between the tag's and gripper's centroids
                if (tag->getCentroid().coordX() < gripperPoint.coordX()) {
                    pilotreq.dx = -1.0f * (gripperPoint.coordX() - tag->getCentroid().coordX());
                }
                // reverse by 1.5x the radius of the cylinder
                float radius = ShapeRootTypeConst(theWorld->thisAgent.gripperObject,
                    CylinderData)->getRadius();
                pilotreq.dx = pilotreq.dx - (1.5f * radius);
                std::cout << std::fabs(pilotreq.dx) << "mm)\n";
                
                // reposition the gripper target object
                const Point& kTagCen = tag->getCentroid();
                Point objFutureEgoPos(std::fabs(pilotreq.dx) + kTagCen.coordX(), kTagCen.coordY(),
                                      kTagCen.coordZ() / 2.0f, egocentric);
                objFutureEgoPos.applyTransform(VRmixin::mapBuilder->localToWorldMatrix, allocentric);
                std::cout << "Repositioning the object to from "
                    << theWorld->thisAgent.gripperObject->getCentroid() << " to " << objFutureEgoPos
                    << std::endl;
                theWorld->thisAgent.gripperObject->setPosition(objFutureEgoPos);
                postStateCompletion();
            }

            $nodeclass CreateGripMonTask : StateNode : doStart {
                $reference KoduInterp::thisAgent;
                $reference GrabActionRunner::objectTagId;
                Shape<AprilTagData> tag = find_if<AprilTagData>(localShS,
                    Kodu::HasAprilTagID(objectTagId));
                std::cout << "creating perceptual task; ";
                thisAgent->ptasks.push(
                    new Kodu::VisualGripperMonitorTask(thisAgent->gripperObject, tag));
                std::cout << "centroid = " << tag->getCentroid() << "; id = "
                    << tag->getTagID();
                std::cout << "; angle = " << tag->getCentroid().atanYX() << std::endl;
                postStateCompletion();
            }

            $setupmachine {
                grab:           GrabObject
                verify:         VerifyObjectGrabbed
                posBody:        RepositionBody
                createTask:     CreateGripMonTask

                grab =GRASP=> verify

                verify =S=> createTask =C=> PostMachineSuccess
                verify =C=> posBody =C=> grab
                verify =F=> SpeechNode("failure could not find a match") =C=> PostMachineFailure
            }
            
        } // end of ExecuteGrabAction

        $nodeclass GrabActionEnd : StateNode : doStart {
            $reference KoduInterp::thisAgent;
            std::cout << "[" << getName() << "]: finishing up grab action\n";

            // reposition the gripper object (in the worldShS) outside the world bounds
            thisAgent->gripperObject->setPosition(Point(3000.0f, 3000.0f, 0.0f, allocentric));
            std::cout << "repositioning the robot's body to "
                << thisAgent->gripperObject->getCentroid() << std::endl;

            // the agent is not longer attempting to grab the object--the agent succeeded in grabbing it
            // the target object is (should be) in the gripper
            thisAgent->manipulationComplete();
            std::cout << "Grab action complete.\n";
            postStateCompletion();
        }

        $setupmachine {
            gStart:     GrabActionStart
            prep:       PrepareBody
            exec:       ExecuteGrabAction
            gEnd:       GrabActionEnd
            
            gStart =S=> prep
            gStart =F=> SpeechNode("failure during start node in grab action") =C=> gEnd

            prep =C=> exec
            exec =S=> gEnd =C=> PostMachineCompletion
            exec =F=> SpeechNode("failure during execution node in grab action") =C=> gEnd
        }
    }

// end of GrabActionRunner

// MotionActionRunner
    
    $nodeclass MotionActionRunner : StateNode {
        
        enum MotionTransType {
            MTT_SIMPLE_MOTION = 0,
            MTT_GO_TO_SHAPE
        };

        enum MotionApproachSegment_t {
            MAS_NO_SEGMENTS = 0,
            MAS_INITIAL,
            MAS_FINAL,
            MAS_NUMB_SEG_TYPES
        };

        $provide Kodu::MotionCommand cmd;
        $provide MotionApproachSegment_t segment;
        $provide const float kInitAppOffset(Kodu::KoduConditionBump::kMaxDistanceAwayToSenseBump + 30);

        $nodeclass MotionStart : StateNode {
            /**
             * If the agent is walking towards a shape, it should first check if it can "simply" turn
             * towards the object and walk straight to it. This function tests that by drawing a
             * rectangle from the robot to the target shape. If any shape is in the rectangle
             * (except for the target and the agent itself), then the agent must revert to the goToShape
             * Pilot request. Otherwise, it can use simple motion.
             *
             * ASSUMPTIONS:
             * 1) The only shapes in the environment are cylinders/canisters. This function does not
             *    assume that there are other things such as walls or other agents (robots) in the
             *    environment.
             *
             * 2) The environment is static. That is, there is only one robot in the environment and
             *    it is the only mobile thing in the environment.
            **/
            Kodu::MotionCommand canUseSimpleMotion(const ShapeRoot& kTarget) {
                $reference MotionActionRunner::kInitAppOffset;
                // gather all the shapes in the world shape space
                std::cout << "checking if agent can do simple motion...\n";
                std::vector<ShapeRoot> worldShapes(worldShS);

                // import them to the local shape space (if it is a cylinder) and get the target object
                ShapeRoot lclTarget;
                std::vector<ShapeRoot> lclShapes;
                std::cout << "importing shapes from world to local...\n";
                for (std::size_t i = 0; i < worldShapes.size(); i++) {
                    if (worldShapes[i]->getType() == cylinderDataType) {
                        lclShapes.push_back(VRmixin::mapBuilder->importWorldToLocal(worldShapes[i]));
                        if (worldShapes[i] == kTarget) {
                            lclTarget = lclShapes.back();
                        }
                    }
                }

                // make sure the target shape is valid (should never be invalid)
                if (!(lclTarget.isValid())) {
                    std::cout << "local target shape was not found... cannot do simple motion\n";
                    return Kodu::MotionCommand();
                }

                // get the centroid of the target and the agent's base offset
                const Point& kTargetPt = lclTarget->getCentroid();
                const float agentBaseOffset = VRmixin::theAgent->getBoundingBoxOffset()[0];

                // calculate points for the pre-image polygon (rectangle/box)
                // length (of box) = the distance from the robot's centroid to the target's centroid
                //const float kLength = kTargetPt.xyDistanceFrom(Point(0, 0, 0, egocentric));
                const float kLength = Kodu::distanceFromAgentToPoint(kTargetPt);
                // halfWidth (of box) = the inflated diameter of the robot
                const float kHalfWidth = agentBaseOffset * 0.85f;
                std::vector<Point> preImagePoly;
                preImagePoly.push_back(Point(kLength,  kHalfWidth, 0, egocentric)); // top left
                preImagePoly.push_back(Point(kLength, -kHalfWidth, 0, egocentric)); // top right
                preImagePoly.push_back(Point(      0, -kHalfWidth, 0, egocentric)); // bottom right
                preImagePoly.push_back(Point(      0,  kHalfWidth, 0, egocentric)); // bottom left

                // create the transformed polygon
                float dtheta = AngSignPi(kTargetPt.atanYX());
                //float dtheta = Kodu::bearingFromAgentToObject(lclTarget);
                std::vector<Point> transPoly;
                for (std::size_t i = 0; i < preImagePoly.size(); i++) {
                    // calculate the transformed x coordinate => x' = (x * cos(theta)) - (y * sin(theta))
                    float xPrime = (preImagePoly[i].coordX() * cos(dtheta))
                                    - (preImagePoly[i].coordY() * sin(dtheta));
                    
                    // calculate the transformed y coordinate => y' = (y * cos(theta)) + (x * sin(theta))
                    float yPrime = (preImagePoly[i].coordY() * cos(dtheta))
                                    + (preImagePoly[i].coordX() * sin(dtheta));

                    // add the xy pair to the point vector
                    transPoly.push_back(Point(xPrime, yPrime, 0, egocentric));
                }
                // close the polygon
                transPoly.push_back(transPoly[0]);

                // put the polygon in the local shape space
                NEW_SHAPE(simpleMotionBox, PolygonData, new PolygonData(localShS, transPoly, true));
                //simpleMotionBox->setObstacle(false);
                simpleMotionBox->setViewable(true);

                // iterate over all shapes in the local shape vector
                const std::size_t kNumbOfCorners = 4;
                for (std::size_t i = 0; i < lclShapes.size(); i++) {
                    // if the current shape is the target, skip it
                    if (lclShapes[i]->getId() == lclTarget->getId())
                        continue;
                    // create the four corners of the shape
                    BoundingBox2D box = lclShapes[i]->getBoundingBox();

                    Point shapeCorners[kNumbOfCorners] = {
                        Point(box.max[0], box.max[1], 0, egocentric),   // top left
                        Point(box.max[0], box.min[1], 0, egocentric),   // top right
                        Point(box.min[0], box.min[1], 0, egocentric),   // bottom right
                        Point(box.min[0], box.max[1], 0, egocentric)    // bottom left
                    };
                    // check if any of them are inside or "on" the simple motion box
                    for (std::size_t j = 0; j < kNumbOfCorners; j++) {
                        if (simpleMotionBox->isInside(shapeCorners[j])) {
                            std::cout << "shape " << lclShapes[i] << " is inside the motion box... ";
                            std::cout << "reverting to goToShape Pilot request.\n";
                            return Kodu::MotionCommand();
                        }
                    }
                }
                std::cout << "agent can use simple motion to walk to shape \"" << lclTarget << "\"\n";
                return Kodu::MotionCommand(ShapeRootTypeConst(kTarget, CylinderData),
                    Kodu::distanceInBetweenAgentAndObject(lclTarget) - kInitAppOffset, dtheta, 0, 0);
            }

            virtual void doStart() {
                $reference KoduInterp::thisAgent;
                $reference MotionActionRunner::cmd;
                $reference MotionActionRunner::segment;
                std::cout << "[" << getName() << "]: starting up motion action runner\n";
                thisAgent->agentIsWalking = true;
                // check if the agent needs to go to an object
                if (thisAgent->currMotionCmd.targetObjectIsValid()) {
                    // get a constant reference to the target shape
                    const ShapeRoot& target = thisAgent->currMotionCmd.getTargetObject();
                    // check if the agent can perform simple motion
                    
                    //************* temp fix
                    if (!thisAgent->isHoldingAnObject()
                        && (cmd = canUseSimpleMotion(target)).isValid())
                    {
                        postStateSignal<MotionTransType>(MTT_SIMPLE_MOTION);
                    }
                    //*************
                    //if ((cmd = canUseSimpleMotion(target)).isValid()) {
                    //    postStateSignal<MotionTransType>(MTT_SIMPLE_MOTION);
                    //}
                    // if not, revert to the goToShape Pilot request
                    else {
                        cmd = thisAgent->currMotionCmd;
                        postStateSignal<MotionTransType>(MTT_GO_TO_SHAPE);
                    }
                    segment = MAS_INITIAL;
                }
                // else, do simple motion
                else {
                    cmd = thisAgent->currMotionCmd;
                    segment = MAS_NO_SEGMENTS;
                    postStateSignal<MotionTransType>(MTT_SIMPLE_MOTION);
                }
                // invalidate the motion command
                thisAgent->currMotionCmd.invalidate();
            }
        }

        /**
         * ASSUMPTIONS:
         * By adding a Motion Command to do simple motion after this nodeclass (without checking if
         * the agent can do simple motion), I am assuming that the environment is:
         *   1) Static. There is one agent pure environment, and objects cannot move unless the one agent
         *      causes the objects to move (intentionally or unintentionally).
         *   2) The environment is rectangular with all objects, including the agent, are inside it.
         *   3) There will be nothing in between the agent and the target object when this nodeclass,
         *      GoToShape, transitions to SimpleMotion.
        **/
        $nodeclass GoToShape : PilotNode(PilotTypes::goToShape) : doStart {
            $reference MotionActionRunner::cmd;
            $reference MotionActionRunner::segment;
            $reference MotionActionRunner::kInitAppOffset;
            $reference KoduInterp::thisAgent;
            std::cout << "[" << getName() << "]: executing goToShape motion command\n";
            pilotreq = PilotRequest(PilotTypes::goToShape);
            ShapeRoot target = cmd.getTargetObject();
            target->setObstacle(false);
            pilotreq.targetShape = target;
            // prevent the agent from moving backwards if there is something in the gripper
            if (thisAgent->isHoldingAnObject()) {
                std::cout << "agent is holding an object... (explicitly) disallowing backward motion\n";
                pilotreq.allowBackwardMotion = false;
            }
            float centroidDist = Kodu::distanceFromAgentToObject(target);
            float spatialDist = Kodu::distanceInBetweenAgentAndObject(target);
            float offset = centroidDist - spatialDist + kInitAppOffset;
            pilotreq.baseOffset = fmat::pack(offset, 0, 0);
            float distLeft = kInitAppOffset - 15.0f;
            cmd = Kodu::MotionCommand(distLeft, 0, 0, 0);
            pilotreq.collisionAction = collisionIgnore;
            segment = MAS_FINAL;
            std::cout << "base offset = " << offset << "mm; distance left = " << distLeft << "mm\n";
        }

        $nodeclass ReportMotionFailure : SpeechNode : doStart {
            std::cout << "[" << getName() << "]\n";
            textstream << "Failed motion command";
        }

        $nodeclass SimpleMotion : StateNode {

            $nodeclass SimpleTurn : PilotNode : doStart {
                $reference MotionActionRunner::cmd;
                $reference MotionActionRunner::segment;
                std::cout << "[" << getName() << "]: ";
                pilotreq = PilotRequest(PilotTypes::walk);
                if (segment == MAS_FINAL && cmd.targetObjectIsValid()) {
                    pilotreq.da = Kodu::bearingFromAgentToObject(cmd.getTargetObject());
                } else {
                    pilotreq.da = cmd.getTurningAngle();
                }
                pilotreq.collisionAction = collisionIgnore;
                std::cout << "simple turn = " << pilotreq.da << " rad (= " 
                          << rad2deg(pilotreq.da) << " deg)\n";
            }

            $nodeclass SimpleWalk : PilotNode : doStart {
                $reference MotionActionRunner::cmd;
                $reference MotionActionRunner::segment;
                std::cout << "[" << getName() << "]: ";
                pilotreq = PilotRequest(PilotTypes::walk);
                if (segment == MAS_FINAL && cmd.targetObjectIsValid()) {
                    pilotreq.dx = Kodu::distanceInBetweenAgentAndObject(cmd.getTargetObject());
                } else {
                    pilotreq.dx = cmd.getDistanceToTravel();
                }
                pilotreq.collisionAction = collisionIgnore;
                std::cout << "simple dist = " << pilotreq.dx << "mm\n";
            }

            $nodeclass SimpleDone : StateNode : doStart {
                $reference MotionActionRunner::segment;
                std::cout << "[" << getName() << "]: incrementing to next segment\n";
                postStateSignal<MotionApproachSegment_t>(segment);
                segment = (MotionApproachSegment_t)(((int)segment + 1) % (int)MAS_NUMB_SEG_TYPES);
            }

            $setupmachine {
                simpleTurn:     SimpleTurn
                simpleWalk:     SimpleWalk
                simpleDone:     SimpleDone

                // find a better way to implement loops in this state machine (w/o MAS_*)
                simpleTurn =C=> simpleWalk =C=> simpleDone
                simpleDone =S<MotionApproachSegment_t>(MAS_INITIAL)=> simpleTurn
                simpleDone =S<MotionApproachSegment_t>(MAS_FINAL)=> PostMachineCompletion
                simpleDone =S<MotionApproachSegment_t>(MAS_NO_SEGMENTS)=> PostMachineCompletion
            }
        }

        $nodeclass MotionEnd : StateNode : doStart {
            $reference KoduInterp::thisAgent;
            $reference MotionActionRunner::cmd;
            std::cout << "[" << getName() << "]: simple motion complete.\n";
            cmd = Kodu::MotionCommand();
            thisAgent->agentIsWalking = false;
            postParentCompletion();
        }

        $setupmachine {
            mStart:     MotionStart
            go2Shape:   GoToShape
            reportFail: ReportMotionFailure
            simMotion:  SimpleMotion
            mEnd:       MotionEnd

            mStart =S<MotionTransType>(MTT_GO_TO_SHAPE)=> go2Shape
            mStart =S<MotionTransType>(MTT_SIMPLE_MOTION)=> simMotion

            go2Shape =PILOT(noError)=> simMotion
            go2Shape =C=> reportFail =C=> mEnd
            simMotion =C=> mEnd
        }
    }

// end of MotionActionRunner

// PageSwitchActionRunner

    $nodeclass PageSwitchActionRunner : StateNode {
        $provide unsigned int waitCount(0);

        $nodeclass PageSwitchStart : StateNode : doStart {
            std::cout << "[" << getName() << "]\n";
            
            $reference KoduInterp::multiplexorRef;
            $reference KoduInterp::evaluatorRef;
            $reference KoduInterp::thisAgent;
            $reference KoduInterp::needToHaltExecution;

            PRINT_ATTRS("Multiplexor is active?", multiplexorRef->isActive());
            PRINT_ATTRS("Multiplexor is in recovery?", multiplexorRef->isInRecovery());
            PRINT_ATTRS("Evaluator is active?", evaluatorRef->isActive());
            PRINT_ATTRS("Agent is walking?", VRmixin::isWalkingFlag);
            PRINT_ATTRS("Attempting manipulation?", thisAgent->isExecutingManipAction());

            if (multiplexorRef->isActive() && !multiplexorRef->isInRecovery()) {
                std::cout << "stopping multiplexor (it is active, but not in recovery mode).\n";
                multiplexorRef->stop();
            }

            if (needToHaltExecution == false) {
                std::cout << "requesting evaluator to stop... (needToHaltExecution = true)\n";
                needToHaltExecution = true;
            }

            if (evaluatorRef->isActive()) {
                std::cout << "stopping evaluator.\n";
                evaluatorRef->stop();
            }

            if (VRmixin::isWalkingFlag == true && !thisAgent->isExecutingManipAction()) {
                std::cout << "aborting the current motion command.\n";
                VRmixin::pilot->pilotAbort();
            }

            if (!evaluatorRef->isActive() && !multiplexorRef->isActive()
                && VRmixin::isWalkingFlag == false && !thisAgent->isExecutingManipAction())
            {
                $reference PageSwitchActionRunner::waitCount;
                if ((++waitCount) == 2) {
                    waitCount = 0;
                    std::cout << "proceeding...\n";
                    postStateCompletion();
                    return;
                }
            }
            std::cout << "waiting...\n";
        }

        $nodeclass SwitchToNewPage : StateNode : doStart {
            std::cout << "[" << getName() << "]: executing the page switch action.\n";
            $reference KoduInterp::thisAgent;
            int newPageIndex = thisAgent->newReqdPage - 1;
            if (thisAgent->pages[newPageIndex] == NULL) {
                std::cerr << "!!! A NULL page (index #" << newPageIndex << ") was requested.\n"
                    << "Ignoring action.\n";
                postStateFailure();
                return;
            }
            // switch to the new page
            std::cout << "Switching to page " << thisAgent->newReqdPage
                << " (index #" << newPageIndex << ")\n";
            Kodu::KoduPage* nextPage = thisAgent->pages[newPageIndex];

            // reinitialize all the primitives on the new page
            const int kRuleCount = nextPage->getRuleCount();
            for (int i = 0; i < kRuleCount; i++) {
                nextPage->getRuleInPos(i)->reinitializePrimitives();
            }
            thisAgent->currPageIndex = newPageIndex;
            nextPage = NULL;

            // if the ptasks queue is not empty, remove all tasks except gripper monitor and localization
            if (!thisAgent->ptasks.empty()) {
                std::size_t numbOfTasks = thisAgent->ptasks.size();
                std::cout << "ptasks queue has " << numbOfTasks << " task(s)...\n";
                Kodu::PerceptualTaskType_t type;
                while (numbOfTasks > 0) {
                    type = thisAgent->ptasks.front()->getType();
                    if (type == Kodu::PT_VIS_GRIPPER_MONITOR || type == Kodu::PT_VIS_LOCALIZATION) {
                        std::cout << "\tadding task #" << thisAgent->ptasks.front()->getTaskId()
                            << " to back of queue.\n";
                        thisAgent->ptasks.push(thisAgent->ptasks.front());
                    } else {
                        std::cout << "\tdeleting task #" << thisAgent->ptasks.front()->getTaskId()
                            << " from the queue.\n";
                        GeneralFncs::deletePtr(thisAgent->ptasks.front());
                    }
                    thisAgent->ptasks.pop();
                    numbOfTasks--;
                }
            } else {
                std::cout << "the perceptual tasks queue is empty... continuing.\n";
            }
            thisAgent->newReqdPage = 0;
            postStateCompletion();
        }

        $nodeclass PageSwitchEnd : StateNode : doStart {
            $reference KoduInterp::evaluatorRef;
            $reference KoduInterp::needToHaltExecution;
            
            std::cout << "[" << getName() << "]: restarting evaluator. ";
            needToHaltExecution = false;
            evaluatorRef->start();

            std::cout << "Page Switch action completion.\n";
            postStateCompletion();
        }

        $setupmachine {
            psStart:        PageSwitchStart
            execSwitch:     SwitchToNewPage
            psEnd:          PageSwitchEnd

            psStart =C=> execSwitch
            psStart =T(500)=> psStart

            execSwitch =C=> psEnd
            execSwitch =F=> PostMachineFailure

            psEnd =C=> PostMachineCompletion
        }
    }

// end of PageSwitchActionRunner

// PlayActionRunner

    $nodeclass PlayActionRunner : StateNode {

        $nodeclass PlayStart : StateNode : doStart {
            $reference KoduInterp::thisAgent;
            std::string wavfile = thisAgent->playQueue.front();
            thisAgent->playQueue.pop();
            postStateSignal<std::string>(wavfile);
        }

        $nodeclass PlayEnd : StateNode : doStart {
            $reference KoduInterp::thisAgent;
            if (thisAgent->hasSoundsToPlay()) {
                postStateCompletion();
            } else {
                std::cout << "All play actions complete.\n";
                postParentCompletion();
            }
        }

        $setupmachine {
            pStart:     PlayStart
            pEnd:       PlayEnd

            pStart =S<std::string>=> SoundNode =T(50)=> pEnd
            pEnd =C=> pStart
        }
    }

    $nodeclass PlayActuator : StateNode : doStart {
        $reference KoduInterp::thisAgent;
        if (thisAgent->hasSoundsToPlay()) {
            std::cout << "All Play actions complete.\n";
            postStateCompletion();
            return;
        }
        std::string wavfile = thisAgent->playQueue.front();
        thisAgent->playQueue.pop();
        postStateSignal<std::string>(wavfile);
    }
    
// end of Play Actuator

// Say Actuator

    $nodeclass SayActuator : StateNode : doStart {
        $reference KoduInterp::thisAgent;
        postStateSignal<std::string>(thisAgent->stringToSpeak);
    }

    $nodeclass CompleteSayActuator : StateNode : doStart {
        $reference KoduInterp::thisAgent;
        thisAgent->stringToSpeak.clear();
        std::cout << "Say action complete.\n";
        postStateCompletion();
    }

// end of Speech Actuator

// Score Actuator

    $nodeclass ScoreActuator : StateNode : doStart {
        $reference KoduInterp::thisAgent;
        $reference KoduInterp::theWorld;
        theWorld->applyGlobalScoreChanges(thisAgent->scoreQueue);
        std::cout << "All Score actions complete.\n";
        postStateCompletion();
    }

// end of Score Actuator

// ==================================================================================== //
    
    virtual void setup() {
        $statemachine {
            initAgent:  InitializeAgent         // initializes the agent
            walkMon:    WalkMonitor             // accumulates the distance the agent has walked
            mplex:      PerceptualMultiplexor   // divides the robot's attention among different tasks
            evaluator:  KoduConditionEvaluator  // evaluates all the rules for the current page
            runner:     KoduActionRunner        // initiates execution of runnable actions
            
            endState:   StateNode
            
            initAgent =C=> { evaluator, walkMon }
            walkMon =T(500)=> walkMon
            
            evaluator =C=> runner
            evaluator =F=> endState

            runner =T(150)=> evaluator
            mplex =C=> endState

            // drop action runner
            dropAct:    DropActionRunner
            dropAct =C=> endState
            
            // grab actuator
            grabAct:    GrabActionRunner
            grabAct =C=> endState

            // motion actuator
            motionAct:  MotionActionRunner
            motionAct =C=> endState

            // speech actuator
            sayAct:     SayActuator
            compSayAct: CompleteSayActuator
            
            sayAct =S<std::string>=> SpeechNode =C=> compSayAct =C=> endState
            
            // sound actuator
            playAct:    PlayActuator
            
            playAct =S<std::string>=> SoundNode =T(25)=> playAct
            playAct =C=> endState
            
            // score actuator
            scoreAct:   ScoreActuator
            scoreAct =C=> endState

            // page switch action runner
            pageSwitchAct:  PageSwitchActionRunner
            pageSwitchAct =C=> endState

            //************ temp fix
            pageSwitchAct =F=> SpeechNode("unhandled switch to null page") =C=> endState
            //************
        }
        // 
        multiplexorRef = mplex;
        evaluatorRef = evaluator;
        runnerRef = runner;
        
        // action runner references
        dropActRef = dropAct;
        grabActRef = grabAct;
        motionActRef = motionAct;
        pageSwitchActRef = pageSwitchAct;
        playActRef = playAct;
        sayActRef = sayAct;
        scoreActRef = scoreAct;
    }
    
private:
    DISALLOW_COPY_ASSIGN(KoduInterp);
}

REGISTER_BEHAVIOR(KoduInterp);