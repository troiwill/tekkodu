// Tekkotsu Library
#include "Behaviors/StateMachine.h"
#include "DualCoding/VRmixin.h"

// C++ Library
#include <cctype>
#include <iostream>
#include <queue>
#include <vector>

// ========= Kodu Library ========= //
#include "Kodu/KoduAgent.h"
#include "Kodu/KoduWorld.h"

// General Functions
#include "Kodu/General/GeneralFncs.h"
#include "Kodu/General/GeneralMacros.h"

// Kodu Parsing
#include "Kodu/Parsing/Parser.h"

// Kodu Primitives
#include "Kodu/Primitives/KoduActionGrab.h"
#include "Kodu/Primitives/KoduActionMotion.h"
#include "Kodu/Primitives/KoduActionPageSwitch.h"
#include "Kodu/Primitives/KoduActionSay.h"
#include "Kodu/Primitives/KoduConditionAlways.h"
#include "Kodu/Primitives/KoduConditionBump.h"
#include "Kodu/Primitives/KoduConditionSee.h"

#include "Kodu/Keepers/ScoreKeeper.h"
#include "Kodu/Keepers/ObjectKeeper.h"
#include "Kodu/KoduPage.h"
#include "Kodu/KoduRule.h"

$nodeclass KoduGame : VisualRoutinesStateNode {
    
    $provide Kodu::KoduWorld* theWorld;
    $provide Kodu::KoduAgent* theAgent;
    $provide unsigned int cycleCount;
    
    $provide GrabActuator* grabActRef;
    $provide MotionActuator* motionActRef;
    $provide PageSwitchActuator* pageSwitchActRef;
    $provide PlayActuator* playActRef;
    $provide SayActuator* sayActRef;
    $provide ScoreActuator* scoreActRef;
    
    ~KoduGame() {
        std::cout << "Destructing Kodu Game...\n";
        // null the KoduAgent pointer
        theAgent = NULL;

        // delete the world instance
        std::cout << "Destroying Kodu World.\n";
        GeneralFncs::deletePtr(theWorld);
        
        std::cout << "Kodu Game destruction complete!\n";
    }

    $nodeclass InitializeAgent : StateNode {
        $reference KoduGame::theWorld;
        $reference KoduGame::theAgent;
        $reference KoduGame::cycleCount;

        std::cout << "Initializing Kodu Game.\n";
        cycleCount = 0;
        
        // create an instance of the Kodu World
        theWorld = new Kodu::KoduWorld("Arthur");
        // point the KoduAgent pointer to KoduWorld::thisAgent
        theAgent = &(theWorld->thisAgent);

        // set the world bounds
        VRmixin::pilot->setWorldBounds(theWorld->getWorldBoundsPolygon());

        std::cout << "Initialization complete.\n";
        postStateCompletion();
    }
    
    //! Kodu Code Parser
    $nodeclass KoduParser : StateNode : doStart {
        $reference KoduGame::theAgent;
        
        // parses and creates Kodu program
        if (Kodu::Parser::parseAndCreateKoduProgram(theAgent->pages) == false) {
            postStateFailure();
            std::cerr << "Error parsing and creating Kodu program.\n";
            return;
        }

        std::cout << "Parsing complete.\n";
        if (theAgent->getCurrentPage()->requiresVision()) {
            postStateCompletion();
        } else {
            postStateFailure();
        }
    }

    $nodeclass SnapImage : MapBuilderNode(MapBuilderRequest::worldMap) : doStart {
        $reference KoduGame::theAgent;
        // search the world for the following objects
        mapreq.addObjectColor(cylinderDataType, "red");
        mapreq.addObjectColor(cylinderDataType, "blue");
        mapreq.addObjectColor(cylinderDataType, "green");
        //mapreq.setAprilTagFamily();

        mapreq.searchArea = theAgent->getGazePolygon();
        //mapreq.doScan = true;
        mapreq.pursueShapes = true;
        //mapreq.maxDist = distantRadius * 1.15f;
    }

    $nodeclass PointHeadFwd : HeadPointerNode : doStart {
        // look ahead at point {x, y, z}
        getMC()->lookAtPoint(2000.0f, 0, 0);
        getMC()->updateOutputs();
    }

    $nodeclass CheckForNorthStar : StateNode : doStart {
        $reference KoduGame::theWorld;
        // check if the north star was visible
        // create a vector (multiple tags may have been seen)
        /*
        NEW_SHAPEVEC(aprilTagsVec, AprilTagData, select_type<AprilTagData>(worldShS));
        bool foundNS = false;
        // check if any april tags were visible
        if (aprilTagsVec.size() > 0) {
            for (unsigned int i = 0; i < aprilTagsVec.size(); i++) {
                if (aprilTagsVec[i]->getTagID() == 0) {
                    std::cout << "Found the North Star!\n";
                    //theWorld->setNorthStar(aprilTagsVec[i], false);
                    foundNS = true;
                    break;
                }
            }
        }
        */
        //if (!foundNS) {
        // get 2D box bounding the world
        BoundingBox2D bounds = theWorld->getWorldBoundsPolygon()->getBoundingBox();
        NEW_SHAPE(artificialNorthStar, PointData,
            new PointData(worldShS,                      // put the northstar in the world shape space
                Point(
                    bounds.max[0],                           // the max x-value
                    ((bounds.max[1] + bounds.min[1]) / 2.0f),// the avg of the max and min y-values
                    0)));                            // z-value; northstar is artificial, only xy matters
        // set the world northstar to the artifically created AprilTag
        theWorld->setNorthStarLocation(artificialNorthStar, true);
        //}
        postStateCompletion();
    }

    
    //! Kodu Interpreter
    $nodeclass KoduInterpreter : StateNode {

        //! Enables child rules with the once modifier enabled (who have already ran) to run (again)
        void resetChildRulesWithOnceEnabled(const unsigned int kParentRuleNumer) {
            $reference KoduGame::theAgent;

            Kodu::KoduPage* page = theAgent->getCurrentPage();
            Kodu::KoduRule* rule = NULL;
            const int kRuleCount = page->getRuleCount();
            for (int childRule_i = kParentRuleNumer + 1; childRule_i < kRuleCount; childRule_i++) {
                // get rule# i
                rule = page->getRule(childRule_i);
                // check if this rule's parent is kParentRuleNumber
                // if it is, set actionCanRun flag to true
                // else break--this rule has no more child actions
                if (rule->getParentNumber() == kParentRuleNumer)
                    rule->action->setActionCanRun(true);
                else
                    break;
            }
            page = NULL;
            rule = NULL;
        }

        virtual void doStart() {
            $reference KoduGame::cycleCount;
            $reference KoduGame::theAgent;
            
            Kodu::KoduPage* cPage;
            Kodu::KoduRule* cRule;
            if ((cPage = theAgent->getCurrentPage()) == NULL) {
                std::cerr << "!!! A NULL page was found.\n";
                postStateFailure();
                return;
            }

            std::cout << "========== GAME CYCLE #" << cycleCount++
                      << ", PAGE #" << cPage->getPageNumber() << "==========\n";
            
            const int numbOfRules = cPage->getRuleCount();
            if (numbOfRules == 0) {
                std::cout << "Reached an empty page. Stopping interpreter...\n";
                postStateFailure();
                return;
            }

            for (int i = 0; i < numbOfRules; i++) {
                // checks if the rule returned is NULL. 
                if ((cRule = cPage->getRuleInPos(i)) == NULL) {
                    std::cerr << "!!! A NULL rule was found. Tried accessing Page["
                              << (cPage->getPageNumber() - 1) << "], Rule[" << i << "]\n";
                    postStateFailure();
                    return;
                }

                // TODO (05/July/2013) Figure out how to cancel a running pilot request
                if (cRule->condition->evaluate() == true) {
                    // resets the action has already ran flag
                    if (cRule->condLastEvalResult == false) {
                        resetChildRulesWithOnceEnabled(cRule->getRuleNumber());
                    }
                    // states condition evaluated true (no matter if action can execute or not)
                    cRule->setConditionEvalResult(true);
                    // check if this rule has a parent rule and if it's condition evaluated true
                    if (cRule->isIndented()
                        && (cPage->getRule(cRule->getParentNumber())->condLastEvalResult == false))
                    {
                        continue;
                    }
                    // check if the action can run
                    if (cRule->action->canRun()) {
                        // Kodu Action Do Nothing
                        if (Kodu::KoduActionDoNothing::isSameTypeAs(cRule->action)) {
                            std::cout << "Do nothing...\n";
                        }

                        // Kodu Action Grab
                        else if (Kodu::KoduActionGrab::isSameTypeAs(cRule->action)) {
                            if (!theAgent->isWalking()) {
                                ShapeRoot targetObject =
                                    dynamic_cast<Kodu::KoduActionGrab*>(cRule->action)->getTargetObject();
                                if (targetObject.isValid() && (targetObject != theAgent->gripperObject)) {
                                    theAgent->gripperObject = targetObject;
                                    std::cout << "Selected an object @ " << targetObject->getCentroid()
                                              << " to be grabbed.\n";
                                }
                            }
                        }

                        // Kodu Action Motion
                        else if (Kodu::KoduActionMotion::isSameTypeAs(cRule->action)) {
                            Kodu::MotionCommand cmd =
                                dynamic_cast<Kodu::KoduActionMotion*>(cRule->action)->getMotionCommand();
                            if (!theAgent->isWalking() && !theAgent->hasMotionCommand() && cmd.isValid()) {
                                theAgent->currMotionCmd = cmd;
                                std::cout << "Added a motion command.\n";
                            }
                        }

                        // Kodu Action Page Switch
                        else if (Kodu::KoduActionPageSwitch::isSameTypeAs(cRule->action)) {
                            theAgent->newReqdPage =
                                dynamic_cast<Kodu::KoduActionPageSwitch*>(cRule->action)->getPageNumber();
                            std::cout << "Switching to another page!\n";
                            break;
                        }

                        // Kodu Action Play
                        else if (Kodu::KoduActionPlay::isSameTypeAs(cRule->action)) {
                            std::string soundFile =
                                dynamic_cast<Kodu::KoduActionPlay*>(cRule->action)->getSoundFile();
                            theAgent->playQueue.push(soundFile);
                            std::cout << "Added the sound file \"" << soundFile << "\".\n";
                        }

                        // Kodu Action Say
                        else if (Kodu::KoduActionSay::isSameTypeAs(cRule->action)
                                 && (!theAgent->hasTextToSay()))
                        {
                            theAgent->stringToSpeak =
                                dynamic_cast<Kodu::KoduActionSay*>(cRule->action)->getStringToSpeak();
                            std::cout << "Added literal string: \"" << theAgent->stringToSpeak << "\".\n";
                        }

                        // Kodu Action Score
                        else if (Kodu::KoduActionScore::isSameTypeAs(cRule->action)) {
                            theAgent->scoreQueue.push(
                                dynamic_cast<Kodu::KoduActionScore*>(cRule->action)->getScoreChange());
                            std::cout << "Added a score action type.\n";
                        }

                        // something wrong has happened, but should never happen
                        else {
                            std::cerr << "Unrecognized action: \""
                                      << cRule->action->getPrimitiveType() << "\"\n";
                        }

                        // check if this action:
                        // 1) [implicit] can use the once modifier, and
                        // 2) has the once modifier enabled
                        if (cRule->action->onceModIsEnabled())
                            cRule->action->setActionCanRun(false);
                    }
                } else {
                    cRule->setConditionEvalResult(false); // states rule evaluated false
                    // check the condition type...
                    // if it is not a timer condition, then set the "action can run" flag to true
                    if (!Kodu::KoduConditionTimer::isSameTypeAs(cRule->condition)) {
                        cRule->action->setActionCanRun(true);
                    }
                }
                // invalidate object
                Kodu::ObjectKeeper::isValid = false;
            }
            cPage = NULL;
            cRule = NULL;
            postStateCompletion();
        }
    } // end of Kodu Interpreter
    
    //! Kodu Action Runner
    $nodeclass KoduActionRunner : StateNode : doStart {
        $reference KoduGame::theAgent;
        $reference KoduGame::grabActRef;
        $reference KoduGame::motionActRef;
        $reference KoduGame::pageSwitchActRef;
        $reference KoduGame::playActRef;
        $reference KoduGame::sayActRef;
        $reference KoduGame::scoreActRef;
        
        if (theAgent->hasNewObjectToGrab())
            grabActRef->start();

        if (theAgent->hasMotionCommand())
            motionActRef->start();

        if (theAgent->hasNewPageNumber())
            pageSwitchActRef->start();

        if (theAgent->hasSoundsToPlay())
            playActRef->start();
        
        if (theAgent->hasTextToSay())
            sayActRef->start();
            
        if (theAgent->hasNewScoreChanges())
            scoreActRef->start();
    }

// ================================ Actuators ========================================= //

// Grab

    $nodeclass GrabActuator : GrasperNode(GrasperRequest::grasp) : doStart {
        $reference KoduGame::theAgent;
        theAgent->setIsAttemptingGrabFlag(true);
        // tell the robot it can move the body to attempt grasp
        graspreq.allowBodyMotion = false;
        // the object the agent should grab
        graspreq.object = theAgent->gripperObject;
        theAgent->startMonitoringWalk();
    }

    $nodeclass CompleteGrabActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        // stop monitoring the walk and calculate approximately how far the agent travelled
        theAgent->stopMonitoringWalk();
        // the agent is not longer attempting to grab the object--the agent succeeded in grabbing it
        theAgent->setIsAttemptingGrabFlag(false);
        // the target object is (should be) in the gripper
        theAgent->setTargetInGripperFlag(true);
        std::cout << "Grab action complete.\n";
        postStateCompletion();
    }

    $nodeclass FailedGrabActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        // stop monitoring the walk and calculate approximately how far the agent travelled
        theAgent->stopMonitoringWalk();
        // the agent is not longer attempting to grab the object--the agent succeeded in grabbing it
        theAgent->setIsAttemptingGrabFlag(false);
        std::cout << "Grab action failed.\n";
        postStateCompletion();
    }

// end of Grab

// Motion 

    $nodeclass MotionActuator : PilotNode : doStart {
        $reference KoduGame::theAgent;
        PilotRequest pReq(PilotTypes::noRequest);
        Kodu::MotionCommand& newCmd = theAgent->currMotionCmd;
        if (newCmd.targetObjectIsValid()) {
            pReq.requestType = PilotTypes::goToShape;
            ShapeRoot target = newCmd.getTargetObject();
            target->setObstacle(false);
            std::cout << "Target Location: " << target->getCentroid() << std::endl;
            pReq.targetShape = target;
            pReq.baseOffset = fmat::pack(Kodu::KoduConditionBump::kMaxDistanceAwayToSenseBump - 60, 0, 0);
        } else {
            pReq.requestType = PilotTypes::walk;
            pReq.da = AngSignPi(newCmd.getTurningAngle());
            pReq.dx = newCmd.getDistanceToTravel();
        }
        pReq.forwardSpeed = newCmd.getForwardSpeed();
        pReq.turnSpeed = newCmd.getTurnSpeed();
        pReq.collisionAction = collisionIgnore;
        pilotreq = pReq;
        newCmd.invalidate();
        theAgent->startMonitoringWalk();
    }

    $nodeclass CompleteMotionActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        theAgent->stopMonitoringWalk();
        std::cout << "Motion action complete.\n";
        postStateCompletion();
    }

// end of Motion

// Page Switch 

    $nodeclass PageSwitchActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        int newPageIndex = theAgent->newReqdPage - 1;
        if (theAgent->pages[newPageIndex] == NULL) {
            std::cerr << "!!! A NULL page (index #" << newPageIndex << ") was requested.\n"
                      << "Ignoring action.\n";
            postStateFailure();
        } else {
            std::cout << "Switching to page " << theAgent->newReqdPage << " (index #" << newPageIndex << ")\n";
            Kodu::KoduPage* nextPage = theAgent->pages[newPageIndex];
            const int kRuleCount = nextPage->getRuleCount();
            for (int i = 0; i < kRuleCount; i++) {
                nextPage->getRuleInPos(i)->reinitializePrimitives();
            }
            theAgent->currPageIndex = newPageIndex;
            nextPage = NULL;
        }
        theAgent->newReqdPage = 0;
        std::cout << "Page switch action complete.\n";
        postStateCompletion();
    }

// end of Page Switch Actuator

// Play Actuator

    $nodeclass PlayActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        if (theAgent->hasSoundsToPlay()) {
            std::cout << "All Play actions complete.\n";
            postStateCompletion();
            return;
        }
        std::string wavfile = theAgent->playQueue.front();
        theAgent->playQueue.pop();
        postStateSignal<std::string>(wavfile);
    }
    
// end of Play Actuator

// Say Actuator

    $nodeclass SayActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        postStateSignal<std::string>(theAgent->stringToSpeak);
    }

    $nodeclass CompleteSayActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        theAgent->stringToSpeak.clear();
        std::cout << "Say action complete.\n";
        postStateCompletion();
    }

// end of Speech Actuator

// Score Actuator

    $nodeclass ScoreActuator : StateNode : doStart {
        $reference KoduGame::theAgent;
        $reference KoduGame::theWorld;
        theWorld->applyGlobalScoreChanges(theAgent->scoreQueue);
        std::cout << "All Score actions complete.\n";
        postStateCompletion();
    }

// end of Score Actuator

// ==================================================================================== //
    
    virtual void setup() {
        $statemachine {
            initAgent:  InitializeAgent

            parser:     KoduParser
            interp:     KoduInterpreter
            runner:     KoduActionRunner

            endState:   StateNode
            
            lookFwd:    PointHeadFwd
            findNS:     CheckForNorthStar
            
            initAgent =C=> parser

            parser =C=> SnapImage =C=> findNS
            parser =F=> findNS
            findNS =C=> { interp, lookFwd }
            
            interp =C=> runner
            interp =F=> endState

            runner =T(150)=> interp
            
            // grab actuator
            grabAct:        GrabActuator
            compGrabAct:    CompleteGrabActuator
            failGrabAct:    FailedGrabActuator

            grabAct =GRASP(noError)=> compGrabAct =C=> endState
            grabAct =GRASP=> failGrabAct =C=> endState

            // motion actuator
            motionAct:      MotionActuator
            compMotionAct:  CompleteMotionActuator

            motionAct =PILOT=> compMotionAct =C=> endState

            // speech actuator
            sayAct:     SayActuator
            compSayAct: CompleteSayActuator
            
            sayAct =S<std::string>=> SpeechNode =C=> compSayAct =C=> endState
            
            // sound actuator
            playAct:    PlayActuator
            
            playAct =S<std::string>=> SoundNode =T(50)=> playAct
            playAct =C=> endState
            
            // score actuator
            scoreAct:   ScoreActuator
            scoreAct =C=> endState

            // page switch actuator
            pageSwitchAct: PageSwitchActuator
            pageSwitchAct =C=> endState
            pageSwitchAct =F=> endState
        }
    
        // actuator references
        grabActRef = grabAct;
        motionActRef = motionAct;
        pageSwitchActRef = pageSwitchAct;
        playActRef = playAct;
        sayActRef = sayAct;
        scoreActRef = scoreAct;
    }
    
private:
    DISALLOW_COPY_ASSIGN(KoduGame);
}

REGISTER_BEHAVIOR(KoduGame);