// Tekkotsu Library
#include "Behaviors/StateMachine.h"
#include "DualCoding/VRmixin.h"

// C++ Library
#include <cctype>
#include <iostream>
#include <queue>
#include <vector>

// ========= Kodu Library ========= //
#include "Kodu/KoduAgent.h"
#include "Kodu/KoduWorld.h"

// General Functions
#include "Kodu/General/GeneralFncs.h"
#include "Kodu/General/GeneralMacros.h"

// Kodu Parsing
#include "Kodu/Parsing/Parser.h"

// Kodu Primitives
#include "Kodu/Primitives/KoduActionGrab.h"
#include "Kodu/Primitives/KoduActionMotion.h"
#include "Kodu/Primitives/KoduActionPageSwitch.h"
#include "Kodu/Primitives/KoduActionSay.h"
#include "Kodu/Primitives/KoduConditionAlways.h"
#include "Kodu/Primitives/KoduConditionBump.h"
#include "Kodu/Primitives/KoduConditionSee.h"

#include "Kodu/PerceptualTasks/VisualBumpDetectionTask.h"

#include "Kodu/Keepers/ScoreKeeper.h"
#include "Kodu/Keepers/ObjectKeeper.h"
#include "Kodu/KoduPage.h"
#include "Kodu/KoduRule.h"

$nodeclass KoduGame : VisualRoutinesStateNode {
    
    $provide Kodu::KoduWorld* theWorld;
    $provide Kodu::KoduAgent* thisAgent;
    $provide unsigned int cycleCount;

    $provide GrabActuator* grabActRef;
    //$provide MotionActuator* motionActRef;

    $provide MotionActionHandler* motionActRef;

    $provide PageSwitchActuator* pageSwitchActRef;
    $provide PlayActuator* playActRef;
    $provide SayActuator* sayActRef;
    $provide ScoreActuator* scoreActRef;
    
    ~KoduGame() {
        std::cout << "Destructing Kodu Game...\n";
        // null the KoduAgent pointer
        thisAgent = NULL;

        // delete the world instance
        std::cout << "Destroying Kodu World.\n";
        GeneralFncs::deletePtr(theWorld);
        
        std::cout << "Kodu Game destruction complete!\n";
    }

    $nodeclass InitializeAgent : StateNode : doStart {
        $reference KoduGame::theWorld;
        $reference KoduGame::thisAgent;
        $reference KoduGame::cycleCount;

        std::cout << "Initializing Kodu Game.\n";
        cycleCount = 0;
        
        // create an instance of the Kodu World
        theWorld = new Kodu::KoduWorld();
        // point the KoduAgent pointer to KoduWorld::thisAgent
        thisAgent = &(theWorld->thisAgent);

        // set the world bounds
        VRmixin::pilot->setWorldBounds(theWorld->getWorldBoundsPolygon());

        std::cout << "Initialization complete.\n";
        postStateCompletion();
    }
    
    //! Kodu Code Parser
    $nodeclass KoduParser : StateNode : doStart {
        $reference KoduGame::thisAgent;
        
        // parses and creates Kodu program
        if (Kodu::Parser::parseAndCreateKoduProgram(thisAgent->pages) == false) {
            postStateFailure();
            std::cerr << "Error parsing and creating Kodu program.\n";
            return;
        }

        std::cout << "Parsing complete.\n";
        if (thisAgent->getCurrentPage()->requiresVision()) {
            postStateCompletion();
        } else {
            postStateFailure();
        }
    }

    $nodeclass SnapImage : MapBuilderNode(MapBuilderRequest::worldMap) : doStart {
        $reference KoduGame::thisAgent;
        // search the world for the following objects
        mapreq.addObjectColor(cylinderDataType, "red");
        mapreq.addObjectColor(cylinderDataType, "blue");
        mapreq.addObjectColor(cylinderDataType, "green");
        //mapreq.setAprilTagFamily();

        mapreq.searchArea = thisAgent->getGazePolygon();
        //mapreq.doScan = true;
        mapreq.pursueShapes = true;
        //mapreq.maxDist = distantRadius * 1.15f;
    }

    $nodeclass PointHeadFwd : HeadPointerNode : doStart {
        // look ahead at point {x, y, z}
        getMC()->lookAtPoint(2000.0f, 0, 0);
    }

    $nodeclass CheckForNorthStar : StateNode : doStart {
        $reference KoduGame::theWorld;
        // check if the north star was visible
        // create a vector (multiple tags may have been seen)
        /*
        NEW_SHAPEVEC(aprilTagsVec, AprilTagData, select_type<AprilTagData>(worldShS));
        bool foundNS = false;
        // check if any april tags were visible
        if (aprilTagsVec.size() > 0) {
            for (unsigned int i = 0; i < aprilTagsVec.size(); i++) {
                if (aprilTagsVec[i]->getTagID() == 0) {
                    std::cout << "Found the North Star!\n";
                    //theWorld->setNorthStar(aprilTagsVec[i], false);
                    foundNS = true;
                    break;
                }
            }
        }
        */
        //if (!foundNS) {
        // get 2D box bounding the world
        BoundingBox2D bounds = theWorld->getWorldBoundsPolygon()->getBoundingBox();
        NEW_SHAPE(artificialNorthStar, PointData,
            new PointData(worldShS,                      // put the northstar in the world shape space
                Point(
                    bounds.max[0],                           // the max x-value
                    ((bounds.max[1] + bounds.min[1]) / 2.0f),// the avg of the max and min y-values
                    0)));                            // z-value; northstar is artificial, only xy matters
        // set the world northstar to the artifically created AprilTag
        theWorld->setNorthStarLocation(artificialNorthStar, true);
        //}
        postStateCompletion();
    }

    
    //! Kodu Interpreter
    $nodeclass KoduInterpreter : StateNode {

        //! Enables child rules with the once modifier enabled (who have already ran) to run (again)
        void resetChildRulesWithOnceEnabled(const unsigned int kParentRuleNumer) {
            $reference KoduGame::thisAgent;

            Kodu::KoduPage* page = thisAgent->getCurrentPage();
            Kodu::KoduRule* rule = NULL;
            const int kRuleCount = page->getRuleCount();
            for (int childRule_i = kParentRuleNumer + 1; childRule_i < kRuleCount; childRule_i++) {
                // get rule# i
                rule = page->getRule(childRule_i);
                // check if this rule's parent is kParentRuleNumber
                // if it is, set actionCanRun flag to true
                // else break--this rule has no more child actions
                if (rule->getParentNumber() == kParentRuleNumer)
                    rule->action->setAgentCanUsePrimitive(true);
                else
                    break;
            }
            page = NULL;
            rule = NULL;
        }

        virtual void doStart() {
            $reference KoduGame::cycleCount;
            $reference KoduGame::thisAgent;

            std::cout << "=== [Kodu Interpreter] ===\n";
            bool hasNewTargetToLookAt = false;

            // pointers to the current page, rule, condition, and action (respectively)
            Kodu::KoduPage* page;
            Kodu::KoduRule* rule;
            Kodu::KoduCondition* cond;
            Kodu::KoduAction* act;
            // check if the current page is NULL
            if ((page = thisAgent->getCurrentPage()) == NULL) {
                std::cerr << "!!! A NULL page was found.\n";
                postStateFailure();
                return;
            }
            // print the current game cycle and page number
            std::cout << "GAME CYCLE #" << cycleCount++ << ", PAGE #" << page->getPageNumber() << "\n";
            // check if there are rules on this page
            const int numbOfRules = page->getRuleCount();
            if (numbOfRules == 0) {
                std::cout << "Reached an empty page. Stopping interpreter...\n";
                postStateFailure();
                return;
            }
            // iterate over all the rules of a page
            for (int i = 0; i < numbOfRules; i++) {
                // checks if the rule returned is NULL. 
                if ((rule = page->getRuleInPos(i)) == NULL) {
                    std::cerr << "!!! A NULL rule was found. Tried accessing Page["
                              << (page->getPageNumber() - 1) << "], Rule[" << i << "]\n";
                    postStateFailure();
                    return;
                }
                
                // the parent ID and rule ID of the current rule (respectively)
                const unsigned int kParentId = rule->getParentNumber();
                const unsigned int kRuleId = rule->getRuleNumber();

                // check if this rule has parent rule and if its condition evaluated true
                if (rule->isIndented() && page->getRule(kParentId)->condLastEvalResult == false) {
                    rule->condLastEvalResult = false;
                    continue;
                }
                
                // point to the current condition and action
                cond = rule->condition;
                act = rule->action;

                
                // check if the agent can evaluate the condition
                if (!cond->agentCanUsePrimitive()) {
                    // check if the condition is a Bump condition and, if so, that the agent is no
                    // longer near the object it was supposed to perceive
                    /*
                    if (cond->getConditionType() == Kodu::KoduCondition::CT_BUMP
                        && !(static_cast<Kodu::KoduConditionBump*>(cond)->agentIsNearMatchingObject())) {
                        cond->setAgentCanUsePrimitive(true);
                    }
                    */
                    // else continue onto the next rule
                    //else {
                        continue;
                    //}
                }
                
                
                // TODO (05/July/2013) Figure out how to cancel a running pilot request
                if (cond->evaluate() == true) {
                    // resets the action has already ran flag
                    if (rule->condLastEvalResult == false) {
                        resetChildRulesWithOnceEnabled(kRuleId);
                    }
                    
                    // states condition evaluated true (no matter if action can execute or not)
                    rule->setConditionEvalResult(true);
                    
                    // check if the action cannot run
                    if (!(act->agentCanUsePrimitive())) {
                        continue;
                    }
                    // check if this action:
                    // 1) [implicit] can use the once modifier, and
                    // 2) has the once modifier enabled
                    if (act->onceModIsEnabled()) {
                        act->setAgentCanUsePrimitive(false);
                    }
                    
                    // check the action type
                    switch(act->getActionType()) {
                        // Kodu Action Do Nothing
                        case Kodu::KoduAction::AT_DO_NOTHING:
                        {
                            std::cout << "Do nothing.\n";
                            break;
                        }

                        // Kodu Action Grab
                        case Kodu::KoduAction::AT_GRAB:
                        {
                            // make sure the agent is not walking
                            if (!thisAgent->isWalking()) {
                                // get the target object
                                ShapeRoot targetObject =
                                    static_cast<Kodu::KoduActionGrab*>(act)->getTargetObject();
                                // make sure the target object is:
                                // 1) valid, and
                                // 2) the target object is not the same as the one in the gripper now
                                if (targetObject.isValid() && targetObject != thisAgent->gripperObject) {
                                    thisAgent->gripperObject = targetObject;
                                    std::cout << "Selected an object " << targetObject
                                              << " to be grabbed.\n";
                                }
                            }
                            break;
                        }

                        // Kodu Action Motion
                        case Kodu::KoduAction::AT_MOTION:
                        {
                            // get the current motion command
                            Kodu::MotionCommand cmd =
                                static_cast<Kodu::KoduActionMotion*>(act)->getMotionCommand();
                            // make sure:
                            // 1) the agent is not walking
                            // 2) the agent does not have a motion command
                            // 3) the "current" motion command (cmd) is valid
                            if (!thisAgent->isWalking() && !thisAgent->hasMotionCommand()
                                && cmd.isValid())
                            {
                                thisAgent->currMotionCmd = cmd;
                                std::cout << "Added a motion command.\n";
                            }
                            break;
                        }

                        // Kodu Action Page Switch
                        case Kodu::KoduAction::AT_PAGE_SWITCH:
                        {
                            // get the new requested page number (agent will switch to it immediately)
                            thisAgent->newReqdPage =
                                static_cast<Kodu::KoduActionPageSwitch*>(act)->getPageNumber();
                            std::cout << "Switching to another page!\n";
                            break;
                        }

                        // Kodu Action Play
                        case Kodu::KoduAction::AT_PLAY:
                        {
                            // get the sound file
                            std::string soundFile =
                                static_cast<Kodu::KoduActionPlay*>(act)->getSoundFile();
                            // add the sound file to the play queue
                            thisAgent->playQueue.push(soundFile);
                            std::cout << "Added the sound file \"" << soundFile << "\".\n";
                            break;
                        }

                        // Kodu Action Say
                        case Kodu::KoduAction::AT_SAY:
                        {
                            // make sure the agent does not have anything to say first
                            if (!thisAgent->hasTextToSay()) {
                                // give the string to the agent
                                thisAgent->stringToSpeak =
                                    static_cast<Kodu::KoduActionSay*>(act)->getStringToSpeak();
                                std::cout << "Added literal string: \""
                                          << thisAgent->stringToSpeak << "\".\n";
                            }
                            break;
                        }

                        // Kodu Action Score
                        case Kodu::KoduAction::AT_SCORING:
                        {
                            // add the score change to the score queue
                            thisAgent->scoreQueue.push(
                                static_cast<Kodu::KoduActionScore*>(act)->getScoreChange());
                            std::cout << "Added a score action type.\n";
                            break;
                        }

                        default:
                        {
                            std::cerr << "Unrecognized action: \""
                                  << act->getPrimitiveType() << "\"\n";
                            break;
                        }
                    }
                    // check if the agent needs to switch pages
                    if (thisAgent->hasNewPageNumber())
                        break;
                } else {
                    // states rule evaluated false
                    rule->setConditionEvalResult(false);
                    // check the condition type...
                    // if it is not a timer condition, then set the "action can run" flag to true
                    if (!cond->getConditionType() != Kodu::KoduCondition::CT_TIMER) {
                        act->setAgentCanUsePrimitive(true);
                    }
                    // check if the condition is type KoduConditionBump
                    // if it is, then check if the condition thinks the agent is near a particular object
                    // if the agent is near a (particular) object, the interpreter should tell the robot
                    // to detect the bump
                    /*
                    if (cond->getConditionType() == Kodu::KoduCondition::CT_BUMP) {
                        Kodu::KoduConditionBump* bmp = static_cast<Kodu::KoduConditionBump*>(cond);
                        if (bmp->agentIsNearMatchingObject() && !thisAgent->isWalking()) {
                            bmp->setAgentCanUsePrimitive(false);
                            thisAgent->bmpDetector.push(bmp);
                            hasNewTargetToLookAt = true;
                        }
                        bmp = NULL;
                    }
                    */
                    if (cond->getConditionType() == Kodu::KoduCondition::CT_BUMP) {
                        cond->setAgentCanUsePrimitive(false);
                        thisAgent->pTasksQueue.push(
                            new Kodu::VisualBumpDetectionTask(static_cast<Kodu::KoduConditionBump*>(cond))
                            );
                        hasNewTargetToLookAt = true;
                    }
                }
                // invalidate object
                Kodu::ObjectKeeper::isValid = false;
                cond = NULL;
                act = NULL;
            }
            page = NULL;
            rule = NULL;
            //postStateSignal<bool>(hasNewTargetToLookAt);
            postStateCompletion();
        }
    } // end of Kodu Interpreter

    $nodeclass PerceptualMultiplexor : StateNode {
        $provide Kodu::PerceptualTaskBase* currentTask;
        $provide unsigned int tasksToExecute;

        enum MultiPlexorTransType_t {
            MPT_MAP_BUILDER = 0,
            MPT_PILOT
        };

        $nodeclass MultiplexorInit : StateNode : doStart {
            $reference PerceptualMultiplexor::tasksToExecute;
            $reference KoduGame::thisAgent;

            tasksToExecute = thisAgent->pTasksQueue.size();
            std::cout << "\n=== [Perceptual Multiplexor] ===\n";
            if (tasksToExecute == 0) {
                std::cout << "No tasks to execute; exiting.\n";
                postParentCompletion();
            } else {
                std::cout << tasksToExecute << " tasks to (possibly) execute!\n";
                postStateCompletion();
            }
        }

        $nodeclass MultiplexorStart : StateNode {

            Kodu::PerceptualTaskBase* getNextExecutableTask() {
                $reference KoduGame::theWorld;
                $reference KoduGame::thisAgent;
                $reference PerceptualMultiplexor::tasksToExecute;

                std::cout << "checking task #'s ";
                while (tasksToExecute > 0) {
                    std::cout << thisAgent->pTasksQueue.front()->getTaskId() << "; ";
                    if (thisAgent->pTasksQueue.front()->canExecute(*theWorld)) {
                        return thisAgent->pTasksQueue.front();
                    }
                    tasksToExecute--;
                    thisAgent->pTasksQueue.push(thisAgent->pTasksQueue.front());
                    thisAgent->pTasksQueue.pop();
                }
                std::cout << std::endl;
                return NULL;
            }

            virtual void doStart() {
                $reference KoduGame::thisAgent;
                $reference PerceptualMultiplexor::currentTask;
                std::cout << "Getting next executable task...\n";
                if ((currentTask = getNextExecutableTask()) == NULL) {
                    std::cout << "no executable tasks left; exiting.\n";
                    postParentCompletion();
                    return;
                }
                std::cout << "task #" << currentTask->getTaskId() << " ";
                // check the task type
                switch (currentTask->getType()) {
                    case Kodu::PT_VIS_BUMP_DETECTION:
                        std::cout << "(Bump Detection).\n";
                        postStateSignal<MultiPlexorTransType_t>(MPT_MAP_BUILDER);
                        return;

                    case Kodu::PT_VIS_WALK_PROGRESS:
                        std::cout << "(Walk Progress).\n";
                        postStateSignal<MultiPlexorTransType_t>(MPT_MAP_BUILDER);
                        return;

                    default:
                        std::cout << "MultiplexorStart: unidentified task found... exiting.\n";
                        postParentCompletion();
                        return;
                }
            }
        }

        $nodeclass MapBuilderTaskRunner : StateNode {

            $nodeclass ExecuteMapBuilderTask : MapBuilderNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                // (generate and) get the mapbuilder request
                mapreq = currentTask->getMapBuilderRequest();
            }

            $nodeclass ExamineMapBuilderResults : StateNode : doStart {
                $reference PerceptualMultiplexor::currentTask;
                // examine the results from the mapbuilder request
                currentTask->examineTaskResults();
                postParentCompletion();
            }

            $setupmachine {
                executeRequest:     ExecuteMapBuilderTask
                examineResults:     ExamineMapBuilderResults

                executeRequest =C=> examineResults
            }
        }

        $nodeclass PilotTaskRunner : PilotNode : doStart {
            $reference PerceptualMultiplexor::currentTask;
            pilotreq = currentTask->getPilotRequest();
        }

        $nodeclass MultiplexorEnd : StateNode : doStart {
            $reference KoduGame::theWorld;
            $reference KoduGame::thisAgent;
            $reference PerceptualMultiplexor::currentTask;
            $reference PerceptualMultiplexor::tasksToExecute;

            // remove the (current) task from the queue
            thisAgent->pTasksQueue.pop();
            // check if the task is complete
            std::cout << "Task #" << currentTask->getTaskId() << " status: ";
            if (currentTask->taskIsComplete(*theWorld)) {
                std::cout << "complete! (removing task).\n";
                // delete the task
                GeneralFncs::deletePtr(currentTask);
            }
            // else, the task is not complete so add it to the end of the queue
            else {
                std::cout << "NOT complete. (adding to end of queue).\n";
                thisAgent->pTasksQueue.push(currentTask);
            }
            std::cout << --tasksToExecute << " more task(s) left to check during this cycle... ";
            // check if there are more tasks on the queue to execute
            if (tasksToExecute == 0) {
                // if there are more tasks, make the task at the front of the queue the current task
                currentTask = thisAgent->pTasksQueue.front();
                std::cout << "exiting.\n";
                postStateCompletion();
            }
            // else, tell the parent state machine the multiplexor is done
            else {
                std::cout << "continuing to next task.\n";
                postParentCompletion();
            }
        }

        $setupmachine {
            initMP:         MultiplexorInit
            startMP:        MultiplexorStart
            runMBTask:      MapBuilderTaskRunner
            runPilotTask:   PilotTaskRunner
            endMP:          MultiplexorEnd

            initMP =C=> startMP

            startMP =S<MultiPlexorTransType_t>(MPT_MAP_BUILDER)=> runMBTask
            startMP =S<MultiPlexorTransType_t>(MPT_PILOT)=> runPilotTask

            runMBTask =C=> endMP
            runPilotTask =C=> endMP

            endMP =C=> startMP
        }

        private:
            DISALLOW_COPY_ASSIGN(PerceptualMultiplexor);
    }





    $nodeclass BumpDetector : MapBuilderNode(MapBuilderRequest::localMap) : doStart {
        NEW_SHAPE(searchPoint, PointData, new PointData(localShS, Point(200, 0, 0, egocentric)));
        mapreq.setAprilTagFamily();
        mapreq.searchArea = searchPoint;
    }

    $nodeclass BumpDetectResults : StateNode : doStart {
        $reference KoduGame::thisAgent;
        /*
        NEW_SHAPE(tag, AprilTagData, find_if<AprilTagData>(localShS));
        std::cout << "Examining results...";
        //Kodu::KoduConditionBump* bmp = thisAgent->bmpDetector.front();
        if (tag.isValid()) {
            std::cout << "found something!\n";
            bmp->setVisualBumpDetection(true);
            bmp->setAgentCanUsePrimitive(true);
        } else {
            std::cout << "nada.\n";
            bmp->setVisualBumpDetection(false);
        }
        //thisAgent->bmpDetector.pop();
        bmp = NULL;
        */
        postStateCompletion();
    }
    
    //! Kodu Action Runner
    $nodeclass KoduActionRunner : StateNode : doStart {
        $reference KoduGame::thisAgent;
        $reference KoduGame::grabActRef;
        $reference KoduGame::motionActRef;
        $reference KoduGame::pageSwitchActRef;
        $reference KoduGame::playActRef;
        $reference KoduGame::sayActRef;
        $reference KoduGame::scoreActRef;
        
        std::cout << "=== [Kodu Action Runner] ===\n";

        if (thisAgent->hasNewObjectToGrab())
            grabActRef->start();

        if (thisAgent->hasMotionCommand())
            motionActRef->start();

        if (thisAgent->hasNewPageNumber())
            pageSwitchActRef->start();

        if (thisAgent->hasSoundsToPlay())
            playActRef->start();
        
        if (thisAgent->hasTextToSay())
            sayActRef->start();
            
        if (thisAgent->hasNewScoreChanges())
            scoreActRef->start();
    }

// ================================ Action Handlers ========================================= //

// Grab

    $nodeclass GrabActuator : GrasperNode(GrasperRequest::grasp) : doStart {
        $reference KoduGame::thisAgent;
        thisAgent->setIsAttemptingGrabFlag(true);
        // tell the robot it can move the body to attempt grasp
        graspreq.allowBodyMotion = false;
        // the object the agent should grab
        graspreq.object = thisAgent->gripperObject;
        thisAgent->startMonitoringWalk();
    }

    $nodeclass CompleteGrabActuator : StateNode : doStart {
        $reference KoduGame::thisAgent;
        // stop monitoring the walk and calculate approximately how far the agent travelled
        thisAgent->stopMonitoringWalk();
        // the agent is not longer attempting to grab the object--the agent succeeded in grabbing it
        thisAgent->setIsAttemptingGrabFlag(false);
        // the target object is (should be) in the gripper
        thisAgent->setTargetInGripperFlag(true);
        std::cout << "Grab action complete.\n";
        postStateCompletion();
    }

    $nodeclass FailedGrabActuator : StateNode : doStart {
        $reference KoduGame::thisAgent;
        // stop monitoring the walk and calculate approximately how far the agent travelled
        thisAgent->stopMonitoringWalk();
        // the agent is not longer attempting to grab the object--the agent succeeded in grabbing it
        thisAgent->setIsAttemptingGrabFlag(false);
        std::cout << "Grab action failed.\n";
        postStateCompletion();
    }

// end of Grab

// Motion Handler
    
    $nodeclass MotionActionHandler : StateNode {
        $provide Kodu::MotionCommand cmd;
        $provide const float kBaseOffset(Kodu::KoduConditionBump::kMaxDistanceAwayToSenseBump - 120.0);

        enum MotionTransType {
            MTT_SIMPLE_MOTION = 0,
            MTT_GO_TO_SHAPE
        };

        $nodeclass MotionStart : StateNode {

            /**
             * If the agent is walking towards a shape, it should first check if it can "simply" turn
             * towards the object and walk straight to it. This function tests that by drawing a
             * rectangle from the robot to the target shape. If any shape is in the rectangle
             * (except for the target and the agent itself), then the agent must revert to the goToShape
             * Pilot request. Otherwise, it can use simple motion.
             *
             * ASSUMPTIONS:
             * 1) The only shapes in the environment are cylinders/canisters. This function does not
             *    assume that there are other things such as walls or other agents (robots) in the
             *    environment.
             *
             * 2) The environment is static. That is, there is only one robot in the environment and
             *    it is the only mobile thing in the environment.
            **/
            Kodu::MotionCommand canUseSimpleMotion(const ShapeRoot& kTarget) {
                $reference MotionActionHandler::kBaseOffset;
                // gather all the shapes in the world shape space
                std::cout << "checking if agent can do simple motion...\n";
                std::vector<ShapeRoot> worldShapes(worldShS);

                // import them to the local shape space (if it is a cylinder) and get the target object
                ShapeRoot lclTarget;
                std::vector<ShapeRoot> lclShapes;
                std::cout << "importing shapes from world to local...\n";
                for (std::size_t i = 0; i < worldShapes.size(); i++) {
                    if (worldShapes[i]->getType() == cylinderDataType) {
                        lclShapes.push_back(VRmixin::mapBuilder->importWorldToLocal(worldShapes[i]));
                        if (worldShapes[i] == kTarget) {
                            lclTarget = lclShapes.back();
                        }
                    }
                }

                // make sure the target shape is valid (should never be invalid)
                if (!(lclTarget.isValid())) {
                    std::cout << "local target shape was not found... cannot do simple motion\n";
                    return Kodu::MotionCommand();
                }

                // get the centroid of the target and the agent's base offset
                const Point& targetPt = lclTarget->getCentroid();
                const float agentBaseOffset = VRmixin::theAgent->getBoundingBoxOffset()[0];

                // calculate points for the pre-image polygon (rectangle/box)
                // length (of box) = the distance from the robot's centroid to the target's centroid
                const float length = targetPt.xyDistanceFrom(Point(0, 0, 0, egocentric));
                // halfWidth (of box) = the inflated diameter of the robot
                const float halfWidth = agentBaseOffset * 0.85f;
                std::vector<Point> preImagePoly;
                preImagePoly.push_back(Point(length,  halfWidth, 0, egocentric));   // top left point
                preImagePoly.push_back(Point(length, -halfWidth, 0, egocentric));   // top right point
                preImagePoly.push_back(Point(     0, -halfWidth, 0, egocentric));   // bottom right point
                preImagePoly.push_back(Point(     0,  halfWidth, 0, egocentric));   // bottom left point

                // create the transformed polygon
                float dtheta = targetPt.atanYX();
                std::vector<Point> transPoly;
                for (std::size_t i = 0; i < preImagePoly.size(); i++) {
                    // calculate the transformed x coordinate ==> x' = (x * cos(theta)) - (y * sin(theta))
                    float xPrime = (preImagePoly[i].coordX() * cos(dtheta))
                                    - (preImagePoly[i].coordY() * sin(dtheta));
                    
                    // calculate the transformed y coordinate ==> y' = (y * cos(theta)) + (x * sin(theta))
                    float yPrime = (preImagePoly[i].coordY() * cos(dtheta))
                                    + (preImagePoly[i].coordX() * sin(dtheta));

                    // add the xy pair to the point vector
                    transPoly.push_back(Point(xPrime, yPrime, 0, egocentric));
                }
                // close the polygon
                transPoly.push_back(transPoly[0]);

                // put the polygon in the local shape space
                NEW_SHAPE(simpleMotionBox, PolygonData, new PolygonData(localShS, transPoly, true));
                //simpleMotionBox->setObstacle(false);
                simpleMotionBox->setViewable(true);

                // iterate over all shapes in the local shape vector
                const std::size_t kNumbOfCorners = 4;
                for (std::size_t i = 0; i < lclShapes.size(); i++) {
                    // if the current shape is the target, skip it
                    if (lclShapes[i]->getId() == lclTarget->getId())
                        continue;
                    // create the four corners of the shape
                    BoundingBox2D box = lclShapes[i]->getBoundingBox();

                    Point shapeCorners[kNumbOfCorners] = {
                        Point(box.max[0], box.max[1], 0, egocentric),   // top left
                        Point(box.max[0], box.min[1], 0, egocentric),   // top right
                        Point(box.min[0], box.min[1], 0, egocentric),   // bottom right
                        Point(box.min[0], box.max[1], 0, egocentric)    // bottom left
                    };
                    // check if any of them are inside or "on" the simple motion box
                    for (std::size_t j = 0; j < kNumbOfCorners; j++) {
                        if (simpleMotionBox->isInside(shapeCorners[j])) {
                            std::cout << "shape " << lclShapes[i] << " is inside the motion box... ";
                            std::cout << "reverting to goToShape Pilot request.\n";
                            return Kodu::MotionCommand();
                        }
                    }
                }
                std::cout << "agent can use simple motion to walk to shape \"" << lclTarget << "\"\n";
                //return Kodu::MotionCommand(length - kBaseOffset, dtheta, 150.0f, 150.0f / 130.0f);
                return Kodu::MotionCommand(Kodu::distanceInBetweenAgentAndObject(lclTarget), dtheta, 0,0);
            }

            virtual void doStart() {
                $reference KoduGame::thisAgent;
                $reference MotionActionHandler::cmd;
                // check if the agent needs to go to an object
                if (thisAgent->currMotionCmd.targetObjectIsValid()) {
                    // get a constant reference to the target shape
                    const ShapeRoot& target = thisAgent->currMotionCmd.getTargetObject();
                    // check if the agent can perform simple motion
                    if ((cmd = canUseSimpleMotion(target)).isValid()) {
                        postStateSignal<MotionTransType>(MTT_SIMPLE_MOTION);
                    }
                    // if not, revert to the goToShape Pilot request
                    else {
                        postStateSignal<MotionTransType>(MTT_GO_TO_SHAPE);
                        cmd = thisAgent->currMotionCmd;
                    }
                }
                // else, do simple motion
                else {
                    postStateSignal<MotionTransType>(MTT_SIMPLE_MOTION);
                    cmd = thisAgent->currMotionCmd;
                }
                // start monitoring the agent's walk
                thisAgent->startMonitoringWalk();
                // invalidate the motion command
                thisAgent->currMotionCmd.invalidate();
                
            }
        }

        /**
         * ASSUMPTIONS:
         * By adding a Motion Command to do simple motion after this nodeclass (without checking if
         * the agent can do simple motion), I am assuming that the environment is:
         *   1) Static. There is one agent pure environment, and objects cannot move unless the one agent
         *      causes the objects to move (intentionally or unintentionally).
         *   2) The environment is rectangular with all objects, including the agent, are inside it.
         *   3) There will be nothing in between the agent and the target object when this nodeclass,
         *      GoToShape, transitions to SimpleMotion.
        **/
        $nodeclass GoToShape : PilotNode(PilotTypes::goToShape) : doStart {
            $reference MotionActionHandler::cmd;
            //$reference MotionActionHandler::kBaseOffset;
            //static float const kAdditionalDistBetweenAgentAndObject = 100.0f;
            pilotreq = PilotRequest(PilotTypes::goToShape);
            ShapeRoot target = cmd.getTargetObject();
            target->setObstacle(false);
            pilotreq.targetShape = target;
            //pilotreq.baseOffset = fmat::pack(kBaseOffset + kAdditionalDistBetweenAgentAndObject, 0, 0);
            float centroidDist = Kodu::distanceFromAgentToObject(target);
            float spatialDist = Kodu::distanceInBetweenAgentAndObject(target);
            pilotreq.baseOffset = fmat::pack(centroidDist - spatialDist + 100, 0, 0);
            // need to fix the speeds for motion (for now they will be zero)
            //float distLeft = kAdditionalDistBetweenAgentAndObject / 2.0f;
            float distLeft = 85.0f;
            cmd = Kodu::MotionCommand(distLeft, 0.0f, 0, 0);
            //pilotreq.forwardSpeed = cmd.getForwardSpeed();
            //pilotreq.turnSpeed = cmd.getTurnSpeed();
            pilotreq.collisionAction = collisionIgnore;
        }

        $nodeclass SimpleMotion : StateNode {

            $nodeclass SimpleTurn : PilotNode : doStart {
                $reference MotionActionHandler::cmd;
                pilotreq = PilotRequest(PilotTypes::walk);
                pilotreq.da = cmd.getTurningAngle();
                //pilotreq.turnSpeed = cmd.getTurnSpeed();
                pilotreq.collisionAction = collisionIgnore;
                std::cout << "simple turn = " << pilotreq.da << " rad (= " 
                          << rad2deg(pilotreq.da) << " deg)\n";
            }

            $nodeclass SimpleWalk : PilotNode : doStart {
                $reference MotionActionHandler::cmd;
                pilotreq = PilotRequest(PilotTypes::walk);
                pilotreq.dx = cmd.getDistanceToTravel();
                //pilotreq.turnSpeed = cmd.getForwardSpeed();
                pilotreq.collisionAction = collisionIgnore;
                std::cout << "simple dist = " << pilotreq.dx << " mm\n";
            }

            $setupmachine {
                simpleTurn:     SimpleTurn
                simpleWalk:     SimpleWalk

                simpleTurn =C=> simpleWalk =C=> PostMachineCompletion
            }
        }

        $nodeclass MotionEnd : StateNode : doStart {
            $reference KoduGame::thisAgent;
            $reference MotionActionHandler::cmd;
            cmd = Kodu::MotionCommand();
            thisAgent->stopMonitoringWalk();
            std::cout << "Motion complete.\n";
            postParentCompletion();
        }

        $setupmachine {
            mStart:     MotionStart
            go2Shape:   GoToShape
            simMotion:  SimpleMotion
            mEnd:       MotionEnd

            mStart =S<MotionTransType>(MTT_GO_TO_SHAPE)=> go2Shape
            mStart =S<MotionTransType>(MTT_SIMPLE_MOTION)=> simMotion

            go2Shape =C=> simMotion
            simMotion =C=> mEnd
        }
    }

// end of Motion

// Page Switch 

    $nodeclass PageSwitchActuator : StateNode : doStart {
        $reference KoduGame::thisAgent;
        int newPageIndex = thisAgent->newReqdPage - 1;
        if (thisAgent->pages[newPageIndex] == NULL) {
            std::cerr << "!!! A NULL page (index #" << newPageIndex << ") was requested.\n"
                      << "Ignoring action.\n";
            postStateFailure();
        } else {
            std::cout << "Switching to page " << thisAgent->newReqdPage
                      << " (index #" << newPageIndex << ")\n";
            Kodu::KoduPage* nextPage = thisAgent->pages[newPageIndex];
            const int kRuleCount = nextPage->getRuleCount();
            for (int i = 0; i < kRuleCount; i++) {
                nextPage->getRuleInPos(i)->reinitializePrimitives();
            }
            thisAgent->currPageIndex = newPageIndex;
            nextPage = NULL;
        }
        thisAgent->newReqdPage = 0;
        std::cout << "Page switch action complete.\n";
        postStateCompletion();
    }

// end of Page Switch Actuator

// Play Actuator

    $nodeclass PlayActuator : StateNode : doStart {
        $reference KoduGame::thisAgent;
        if (thisAgent->hasSoundsToPlay()) {
            std::cout << "All Play actions complete.\n";
            postStateCompletion();
            return;
        }
        std::string wavfile = thisAgent->playQueue.front();
        thisAgent->playQueue.pop();
        postStateSignal<std::string>(wavfile);
    }
    
// end of Play Actuator

// Say Actuator

    $nodeclass SayActuator : StateNode : doStart {
        $reference KoduGame::thisAgent;
        postStateSignal<std::string>(thisAgent->stringToSpeak);
    }

    $nodeclass CompleteSayActuator : StateNode : doStart {
        $reference KoduGame::thisAgent;
        thisAgent->stringToSpeak.clear();
        std::cout << "Say action complete.\n";
        postStateCompletion();
    }

// end of Speech Actuator

// Score Actuator

    $nodeclass ScoreActuator : StateNode : doStart {
        $reference KoduGame::thisAgent;
        $reference KoduGame::theWorld;
        theWorld->applyGlobalScoreChanges(thisAgent->scoreQueue);
        std::cout << "All Score actions complete.\n";
        postStateCompletion();
    }

// end of Score Actuator

// ==================================================================================== //
    
    virtual void setup() {
        $statemachine {
            initAgent:  InitializeAgent

            parser:     KoduParser

            mplex:      PerceptualMultiplexor

            interp:     KoduInterpreter
            runner:     KoduActionRunner
            bmpDetect:  BumpDetector
            bmpResult:  BumpDetectResults

            endState:   StateNode
            
            lookFwd:    PointHeadFwd
            findNS:     CheckForNorthStar
            
            initAgent =C=> parser

            parser =C=> SnapImage =C=> findNS
            parser =F=> findNS
            //findNS =C=> lookFwd =C=> interp
            findNS =C=> lookFwd =C=> mplex 
            mplex =C=> interp
            
            //lookFwd =C=> endState
            //interp =C=> runner
            //interp =F=> endState

            //interp =S<bool>(true)=> { bmpDetect, runner }
            //interp =S<bool>(false)=> runner
            //bmpDetect =C=> bmpResult
            interp =C=> runner

            //runner =T(150)=> interp
            runner =T(150)=> mplex
            
            // grab actuator
            grabAct:        GrabActuator
            compGrabAct:    CompleteGrabActuator
            failGrabAct:    FailedGrabActuator

            grabAct =GRASP(noError)=> compGrabAct =C=> endState
            grabAct =GRASP=> failGrabAct =C=> endState

            // motion actuator
            //motionAct:      MotionActuator
            //compMotionAct:  CompleteMotionActuator
            
            //motionAct =PILOT=> compMotionAct =C=> endState
            motionAct:      MotionActionHandler

            motionAct =C=> endState

            // speech actuator
            sayAct:     SayActuator
            compSayAct: CompleteSayActuator
            
            sayAct =S<std::string>=> SpeechNode =C=> compSayAct =C=> endState
            
            // sound actuator
            playAct:    PlayActuator
            
            playAct =S<std::string>=> SoundNode =T(25)=> playAct
            playAct =C=> endState
            
            // score actuator
            scoreAct:   ScoreActuator
            scoreAct =C=> endState

            // page switch actuator
            pageSwitchAct: PageSwitchActuator
            pageSwitchAct =C=> endState
            pageSwitchAct =F=> endState
        }
    
        // actuator references
        grabActRef = grabAct;
        motionActRef = motionAct;
        pageSwitchActRef = pageSwitchAct;
        playActRef = playAct;
        sayActRef = sayAct;
        scoreActRef = scoreAct;
    }
    
private:
    DISALLOW_COPY_ASSIGN(KoduGame);
}

REGISTER_BEHAVIOR(KoduGame);